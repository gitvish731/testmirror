// perf/k6/scenarios/from-playwright.http.min.js
// Super-minimal runner for k6 v0.46 that records per-feature/endpoint stats
// and re-exports handleSummary.

import http from 'k6/http';
import { sleep, check } from 'k6';
import featuresMap from '../sources/endpoints.byFeature.js';
import { note } from '../vendor/acc.js';
export { default as handleSummary } from '../vendor/handleSummary.js';

// ------- env / CLI -------
const RAW_FEATURES = String(__ENV.FEATURES || '').trim();
const SELECTED = RAW_FEATURES ? RAW_FEATURES.split(',').map(s => s.trim()).filter(Boolean) : Object.keys(featuresMap || {});
const VUS = Number(__ENV.VUS || 1);
const ITERS = Number(__ENV.ITERS || 0);
const DURATION = String(__ENV.DURATION || '30s');

// log what we see
console.log('parsed -> vus=' + VUS + ', iters=' + ITERS + ', duration=' + DURATION + ', features=' + SELECTED.join('|'));

// ------- options -------
export const options = (function () {
  if (ITERS > 0) {
    return {
      scenarios: {
        by_iter: {
          executor: 'per-vu-iterations',
          vus: VUS,
          iterations: ITERS,
          gracefulStop: '3s',
        },
      },
      thresholds: {},
    };
  } else {
    return {
      scenarios: {
        by_time: {
          executor: 'constant-vus',
          vus: VUS,
          duration: DURATION,
          gracefulStop: '3s',
        },
      },
      thresholds: {},
    };
  }
})();

// ------- tiny helpers -------
function asHeaders(obj) {
  var h = {};
  if (!obj) return h;
  for (var k in obj) { if (obj.hasOwnProperty(k)) h[k] = String(obj[k]); }
  return h;
}

// ------- main -------
export default function () {
  for (var i = 0; i < SELECTED.length; i += 1) {
    var feature = SELECTED[i];
    var list = (featuresMap && featuresMap[feature]) ? featuresMap[feature] : [];
    if (!list || !list.length) continue;

    // keep it simple: run each declared endpoint once per VU iteration
    for (var j = 0; j < list.length; j += 1) {
      var ep = list[j] || {};
      var name = ep.name || ('endpoint-' + j);

      var params = { headers: asHeaders(ep.headers || {}) };
      var res;

      // only GET is needed for your current case; others kept for later
      var started = Date.now();
      try {
        if ((ep.method || 'GET').toUpperCase() === 'GET') {
          res = http.get(ep.url, params);
        } else if (ep.method && ep.method.toUpperCase() === 'POST') {
          res = http.post(ep.url, ep.body || null, params);
        } else if (ep.method && ep.method.toUpperCase() === 'PATCH') {
          res = http.patch(ep.url, ep.body || null, params);
        } else if (ep.method && ep.method.toUpperCase() === 'DELETE') {
          res = http.del(ep.url, null, params);
        } else {
          // fallback to GET
          res = http.get(ep.url, params);
        }
      } catch (e) {
        // network error â€” still record with 0 duration so we see the attempt
        note(feature, name, 0);
        console.log('WARN network error for ' + feature + ' / ' + name + ': ' + String(e && e.message));
        continue;
      }
      var dur = res && res.timings && typeof res.timings.duration === 'number' ? res.timings.duration : (Date.now() - started);
      note(feature, name, dur);

      // minimal checks (optional)
      var exp = ep.expect || {};
      if (typeof exp.status === 'number') {
        check(res, { 'status ok': (r) => r.status === exp.status });
      }
      if (typeof exp.text === 'string' && exp.text) {
        var body = res && res.body ? String(res.body) : '';
        check(res, { 'body has text': () => body.indexOf(String(exp.text)) !== -1 });
      }
    }
  }

  // be a tiny bit nice to the server
  sleep(0.2);
}
