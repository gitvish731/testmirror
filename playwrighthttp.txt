/* eslint-disable */

// k6 runner that emits per-request tags and pushes data into vendor/accumulator

import http from 'k6/http';
import { check, sleep } from 'k6';
import { textSummary } from 'https://jslib.k6.io/k6-summary/0.0.4/index.js';

// ---- local vendor helpers (CommonJS) ---------------------------------------
const ACC = require('../vendor/accumulator.js');          // must export add(feature, endpoint, durMs, ok) and snapshot()
const vendorSummary = require('../vendor/handleSummary.js'); // must export function (data) -> { 'reports/summary.html': html }

// ---- ENV -------------------------------------------------------------------
const ENV = (__ENV.ENV || 'dev').toLowerCase();
const BASE_URL = (__ENV.BASE_URL || '').trim();
const TOKEN = (__ENV.TOKEN || '').trim();

const FEATURES_RAW = (__ENV.FEATURES || '').trim();          // comma list or empty for all
const ENDPOINT_FILTER = (__ENV.ENDPOINT_FILTER || '').trim(); // substring filter (optional)

const DURATION = Number(__ENV.DURATION || '20'); // seconds
const RPS      = Number(__ENV.RPS      || '1');
const PREALLOC = Number(__ENV.PREALLOC || '5');
const MAXVUS   = Number(__ENV.MAXVUS   || '35');

// ---- endpoints map ---------------------------------------------------------
const ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));

// ---- util ------------------------------------------------------------------
function allFeatures() {
  const keys = Object.keys(ENDPOINTS_BY_FEATURE || {});
  return (FEATURES_RAW ? FEATURES_RAW.split(',') : keys)
    .map(s => String(s).trim())
    .filter(Boolean);
}

function selectEndpoints(features) {
  const out = [];
  for (let i = 0; i < features.length; i++) {
    const feature = features[i];
    const list = ENDPOINTS_BY_FEATURE[feature] || [];
    for (let j = 0; j < list.length; j++) {
      const ep = list[j];
      if (ENDPOINT_FILTER && String(ep.name).indexOf(ENDPOINT_FILTER) === -1) continue;
      out.push({ feature, ep }); // { feature, ep:{ name, method, url, expectStatus, mustContain, body } }
    }
  }
  return out;
}

function buildHeaders(method) {
  const h = { accept: 'application/json' };
  if (TOKEN) h.authorization = 'Bearer ' + TOKEN;
  if (method && method !== 'GET' && method !== 'DELETE') {
    h['content-type'] = 'application/json';
  }
  return h;
}

function resolveURL(rawUrl) {
  try { new URL(rawUrl); return rawUrl; } catch (_) {}
  let base = BASE_URL;
  if (!base) {
    base = (ENV === 'uat')
      ? (__ENV.UAT_BASE || 'https://your-uat-host')
      : (__ENV.DEV_BASE || 'https://your-dev-host');
  }
  if (base.endsWith('/')) base = base.slice(0, -1);
  if (!rawUrl.startsWith('/')) rawUrl = '/' + rawUrl;
  return base + rawUrl;
}

// ---- request wrapper (no spread syntax) ------------------------------------
function fire(method, url, body, params, feature, endpoint, expectStatus, mustContain) {
  const tags = { feature: String(feature), endpoint: String(endpoint) };
  const p = Object.assign({}, params || {}, { tags, headers: buildHeaders(method) });

  const t0 = Date.now();

  let res;
  if (method === 'GET') res = http.get(url, p);
  else if (method === 'DELETE') res = http.del(url, null, p);
  else if (method === 'PATCH') res = http.patch(url, body || '', p);
  else if (method === 'PUT') res = http.put(url, body || '', p);
  else res = http.post(url, body || '', p);

  // build checks without object spread
  const checks = {};
  checks['status ok'] = (r) => r.status === (expectStatus || 200);
  if (mustContain) {
    checks['body has text'] = (r) => String(r.body || '').indexOf(String(mustContain)) !== -1;
  }
  const ok = check(res, checks, tags);

  const dur = Date.now() - t0;
  try { ACC.add(feature, endpoint, dur, !!ok); } catch (_) {}

  return res;
}

// ---- scenarios --------------------------------------------------------------
const FEATURE_LIST = allFeatures();
const SELECTED = selectEndpoints(FEATURE_LIST);

const scenarios = {};
for (let i = 0; i < SELECTED.length; i++) {
  const name = `ep_${i}`;
  scenarios[name] = {
    executor: 'constant-arrival-rate',
    rate: RPS,
    timeUnit: '1s',
    duration: `${DURATION}s`,
    preAllocatedVUs: PREALLOC,
    maxVUs: MAXVUS,
    tags: { feature: SELECTED[i].feature, endpoint: SELECTED[i].ep.name },
  };
}

export const options = {
  scenarios,
  thresholds: {
    'http_req_failed': ['rate<0.05'],
  },
};

// ---- main -------------------------------------------------------------------
export default function () {
  for (let i = 0; i < SELECTED.length; i++) {
    const { feature, ep } = SELECTED[i];
    const url = resolveURL(ep.url);
    const method = String(ep.method || 'GET').toUpperCase();
    const body = ep.body ? JSON.stringify(ep.body) : '';
    fire(method, url, body, {}, feature, ep.name, ep.expectStatus || 200, ep.mustContain || null);
  }
  sleep(1);
}

// ---- summary ---------------------------------------------------------------
export function handleSummary(data) {
  // prefer vendor HTML; fall back to text summary
  if (vendorSummary && typeof vendorSummary === 'function') {
    try { return vendorSummary(data); } catch (_) { /* fall back */ }
  }
  return { stdout: textSummary(data, { indent: ' ', enableColors: true }) };
}
