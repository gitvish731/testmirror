// perf/k6/scenarios/from-playwright.http.js
/* eslint-disable no-undef */
/**
 * k6 runner (no transpile). Reads endpoints map, builds scenarios per endpoint,
 * tags every request, and writes rich HTML report via vendor/handleSummary.js
 */

const http = require('k6/http');
const { check, sleep } = require('k6');
const handleSummary = require('../vendor/handleSummary.js');

// ---- Load endpoints map (CommonJS wrapper; first JSON, fallback to .js)
let ENDPOINTS_BY_FEATURE;
try {
  ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));
} catch (_) {
  ENDPOINTS_BY_FEATURE = require('../sources/endpoints.byFeature.js');
}

// ---- Read environment / knobs
const ENV = (String(__ENV.ENV || 'dev').toLowerCase());
const FEATURES_RAW = String(__ENV.FEATURES || '').trim();
const ENDPOINT_FILTER = String(__ENV.ENDPOINT_FILTER || '').toLowerCase() || null;

const RPS   = Number(__ENV.RPS || '1');        // per-scenario arrival rate
const DURATION = String(__ENV.DURATION || '30s');
const PREALLOC = Number(__ENV.PREALLOC || '5');
const MAXVUS   = Number(__ENV.MAXVUS || '60');

const TOKEN = String(__ENV.TOKEN || __ENV.GRAFEAS_LOGIN_TOKEN || '');
const BASE_URL = String(__ENV.BASE_URL || '');

// consistency for the reporter
const THRESHOLDS_ON = (String(__ENV.THRESHOLDS_ON || 'false').toLowerCase() === 'true');

// ---- Helper: host override for dev / uat if full URL provided
function withHost(url) {
  try {
    const u = new URL(url);
    if (ENV === 'dev') u.hostname = u.hostname.replace(/-test\b/i, '-dev');
    if (ENV === 'uat') u.hostname = u.hostname.replace(/-dev\b/i, '-test');
    return u.toString();
  } catch (_) {
    // relative path + optional BASE_URL
    if (!BASE_URL) return url;
    const u = new URL(url, BASE_URL);
    return u.toString();
  }
}

// ---- Select features/endpoints (no modern syntax)
function selectEndpoints(map) {
  // features list
  var selectedFeatures = [];
  if (FEATURES_RAW) {
    var parts = FEATURES_RAW.split(',').map(function (s) { return String(s || '').trim(); })
      .filter(function (s) { return !!s; });
    selectedFeatures = parts;
  } else {
    selectedFeatures = Object.keys(map);
  }

  var out = [];
  for (var i = 0; i < selectedFeatures.length; i++) {
    var feat = selectedFeatures[i];
    var list = map[feat] || [];
    for (var j = 0; j < list.length; j++) {
      var ep = list[j];
      // endpoint name filter (only skip when a filter exists AND it doesn't match)
      var nm = String(ep && ep.name ? ep.name : '').toLowerCase();
      if (ENDPOINT_FILTER && nm.indexOf(ENDPOINT_FILTER) === -1) continue;

      // build plain object (avoid spread)
      var rec = {
        feature: feat,
        name: ep.name,
        method: ep.method,
        url: withHost(ep.url || ep.path || ep.uri || ''),
        headers: ep.headers || {},
        auth: ep.auth || null,
        body: ep.body,
        expect: ep.expect || {}
      };
      out.push(rec);
    }
  }
  return out;
}

var ENDPOINTS = selectEndpoints(ENDPOINTS_BY_FEATURE);

// print a concise selection summary
console.log(
  'Selected ' + ENDPOINTS.length + ' endpoint(s) across FEATURES: [' +
  Object.keys(ENDPOINTS_BY_FEATURE).join(', ') + '] ' +
  (ENDPOINT_FILTER ? ' with ENDPOINT_FILTER=' + ENDPOINT_FILTER : '')
);

// ---- Build scenarios: one per endpoint
var scenarios = {};
for (var s = 0; s < ENDPOINTS.length; s++) {
  var ep = ENDPOINTS[s];
  var scenName = 'ep_' + s; // stable, short
  scenarios[scenName] = {
    executor: 'constant-arrival-rate',
    rate: RPS,
    timeUnit: '1s',
    duration: DURATION,
    preAllocatedVUs: PREALLOC,
    maxVUs: MAXVUS,
    exec: scenName,
  };

  // Dynamically create the scenario function without modern syntax
  (function register(epIdx, epDef, fnName) {
    // headers per request (auth only for write methods)
    function buildHeaders(method) {
      var h = {};
      // copy user headers without mutating source
      var src = epDef.headers || {};
      for (var k in src) if (Object.prototype.hasOwnProperty.call(src, k)) h[k] = src[k];

      if (method === 'POST' || method === 'PUT' || method === 'PATCH' || method === 'DELETE') {
        if (!h['Content-Type']) h['Content-Type'] = 'application/json';
        if (epDef.auth === 'bearer' || TOKEN) {
          // Token from env only (we avoid literal "Authorization": "Bearer")
          if (TOKEN) h['Authorization'] = 'Bearer ' + TOKEN;
        }
      }
      return h;
    }

    // register global function k6 will call
    global[fnName] = function () {
      var method = String(epDef.method || 'GET').toUpperCase();
      var url = epDef.url;
      var headers = buildHeaders(method);

      var tags = { feature: epDef.feature, endpoint: epDef.name || fnName, method: method };

      var res;
      if (method === 'GET') {
        res = http.get(url, { headers: headers, tags: tags });
      } else if (method === 'POST') {
        res = http.post(url, epDef.body || '', { headers: headers, tags: tags });
      } else if (method === 'PUT') {
        res = http.put(url, epDef.body || '', { headers: headers, tags: tags });
      } else if (method === 'PATCH') {
        res = http.patch(url, epDef.body || '', { headers: headers, tags: tags });
      } else if (method === 'DELETE') {
        res = http.del(url, null, { headers: headers, tags: tags });
      } else {
        // fallback as generic request
        res = http.request(method, url, epDef.body || '', { headers: headers, tags: tags });
      }

      var expectStatus = (epDef.expect && epDef.expect.status) ? Number(epDef.expect.status) : 200;
      var ok = check(res, { 'status ok': function (r) { return r.status === expectStatus; } }, tags);

      // Push per-request metadata for reporter (avoid spread)
      if (!global.__k6_meta) global.__k6_meta = [];
      global.__k6_meta.push({
        feature: epDef.feature,
        endpoint: epDef.name || fnName,
        method: method,
        status: res.status,
        dur: res.timings ? res.timings.duration : null,
        ttfb: res.timings ? res.timings.waiting : null
      });

      // Optional text contains
      var need = epDef.expect && epDef.expect.text ? String(epDef.expect.text) : null;
      if (need) {
        check(res, { 'body has text': function (r) { return String(r.body || '').indexOf(need) !== -1; } }, tags);
      }

      sleep(0.1);
      return ok;
    };
  })(s, ep, scenName);
}

// ---- Export k6 options and default
var thresholds = {};
if (THRESHOLDS_ON) {
  thresholds['http_req_failed'] = ['rate<0.01'];
  thresholds['http_req_duration{expected_response:true}'] = ['p(95)<1000'];
}

export const options = {
  scenarios: scenarios,
  thresholds: thresholds
};

export default function () {
  // will never be called; k6 uses named exec functions above
}

// ---- Summary (HTML written by handleSummary)
export function handleSummary(data) {
  return handleSummary(data);
}
