/* perf/k6/scenarios/from-playwright.http.js */

/* k6 builtins */
import http from 'k6/http';
import { check, sleep } from 'k6';

/* ---- load endpoints map (JSON generated by your generator) ----
   NOTE: path is relative to this file.
*/
const ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));

/* ---- wire CommonJS handleSummary (donâ€™t convert this to ESM) ---- */
const handleSummaryFn = require('../vendor/handleSummary.js');
export function handleSummary(data) {
  return handleSummaryFn(data);
}

/* ---- read environment knobs ---- */
const ENV = __ENV || {};
const RUN_ENV = (ENV.env || ENV.ENV || '').toLowerCase();   // e.g. 'dev' or 'uat'
const FEATURES_RAW = (ENV.FEATURES || ENV.features || '').trim();
const ENDPOINT_FILTER = (ENV.ENDPOINT_FILTER || '').trim(); // substring match on endpoint name
const BASE_URL = (ENV.BASE_URL || '').trim();               // optional origin override
const TOKEN =
  (ENV.token || ENV.TOKEN || ENV.GRAFEAS_LOGIN_TOKEN || '').trim(); // bearer for non-GET
const DURATION = ENV.DURATION || '30s';
const RPS = Number(ENV.RPS || 1);
const PREALLOC = Number(ENV.PREALLOC || 5);
const MAXVUS = Number(ENV.MAXVUS || 10);
const THRESHOLDS_ON = String(ENV.THRESHOLDS || 'true').toLowerCase() !== 'false';

/* ---- small helpers ---- */
function log(...a) {
  // eslint-disable-next-line no-console
  console.log.apply(console, a);
}

function normalizeFeatureName(name) {
  // The generator now writes clean names, but we also accept keys as-is.
  return String(name || '').trim();
}

function pickFeatures() {
  const all = Object.keys(ENDPOINTS_BY_FEATURE);
  if (!FEATURES_RAW) return all;
  const wanted = FEATURES_RAW.split(',').map((s) => normalizeFeatureName(s));
  return all.filter((f) => wanted.indexOf(f) !== -1);
}

function urlWithBase(url) {
  if (!BASE_URL) return url;
  try {
    const u = new URL(url);
    const b = new URL(BASE_URL);
    u.protocol = b.protocol;
    u.host = b.host;
    return u.toString();
  } catch (_) {
    return url; // if parsing fails, keep original
  }
}

function headersFor(method) {
  const h = {};
  if (method !== 'GET') {
    if (TOKEN) h['Authorization'] = `Bearer ${TOKEN}`;
    h['Content-Type'] = 'application/json';
  }
  return h;
}

function shouldKeepEndpoint(ep) {
  if (!ENDPOINT_FILTER) return true;
  return String(ep.name || '').toLowerCase().includes(ENDPOINT_FILTER.toLowerCase());
}

/* ---- flatten selected endpoints into a list with feature context ---- */
const SELECTED_FEATURES = pickFeatures();
const ENDPOINTS = [];
for (const feature of SELECTED_FEATURES) {
  const arr = ENDPOINTS_BY_FEATURE[feature] || [];
  for (const ep of arr) {
    if (shouldKeepEndpoint(ep)) ENDPOINTS.push({ feature, ep });
  }
}
log(`Selected ${ENDPOINTS.length} endpoint(s) across FEATURES: ${SELECTED_FEATURES.join(', ')}`);

/* ---- dynamic scenarios: one per endpoint, single runner function with per-scenario env ---- */
const scenarios = {};
ENDPOINTS.forEach(({ feature, ep }, i) => {
  scenarios[`ep_${i}`] = {
    executor: 'constant-arrival-rate',
    exec: 'run',                 // single dispatcher below
    rate: RPS,
    timeUnit: '1s',
    duration: DURATION,
    preAllocatedVUs: PREALLOC,
    maxVUs: MAXVUS,
    gracefulStop: '30s',
    env: { EP_INDEX: String(i) }, // lets run() know which endpoint to execute
    tags: { feature, endpoint: ep.name },
  };
});

/* ---- thresholds (optional) ---- */
const thresholds = THRESHOLDS_ON
  ? {
      http_req_failed: ['rate<0.01'], // <1% failures
      http_req_duration: ['p(95)<60000'], // 95th percentile < 60s (tune as needed)
    }
  : {};

/* ---- export k6 options ---- */
export const options = {
  scenarios,
  thresholds,
  // Quiet the default summary text; we render our own via handleSummary()
  summaryTrendStats: ['avg', 'med', 'min', 'max', 'p(90)', 'p(95)'],
};

/* ---- the dispatcher function per scenario ---- */
export function run() {
  const idx = Number(__ENV.EP_INDEX || 0);
  const ctx = ENDPOINTS[idx];
  if (!ctx) return;

  const feature = ctx.feature;
  const ep = ctx.ep;

  const tags = { feature, endpoint: ep.name };
  const expectStatus = (ep.expect && ep.expect.status) || 200;
  const mustContain = ep.expect && ep.expect.text ? String(ep.expect.text) : null;

  const method = String(ep.method || 'GET').toUpperCase();
  const url = urlWithBase(String(ep.url || ''));
  const headers = headersFor(method);

  let res;
  switch (method) {
    case 'GET':
      res = http.get(url, { headers, tags });
      break;
    case 'POST':
      res = http.post(url, ep.body || null, { headers, tags });
      break;
    case 'PATCH':
      res = http.patch(url, ep.body || null, { headers, tags });
      break;
    case 'DELETE':
      // k6 requires null body arg for del when passing params
      res = http.del(url, null, { headers, tags });
      break;
    default:
      res = http.request(method, url, ep.body || null, { headers, tags });
      break;
  }

  check(
    res,
    {
      'status ok': (r) => r.status === expectStatus,
      ...(mustContain
        ? { 'body has text': (r) => String(r.body || '').indexOf(mustContain) !== -1 }
        : {}),
    },
    tags
  );

  // small think time; adjust/remove if you prefer strict arrival-rate only
  sleep(0.1);
}

/* EOF */
