// perf/k6/scenarios/from-playwright.http.min.js
import http from "k6/http";
import { sleep } from "k6";
import { Trend, Counter } from "k6/metrics";
import features from "../sources/endpoints.byFeature.js";

// ---------- env ----------
const FEAT_RAW = String(__ENV.FEATURES || "").trim();
const VUS      = Number(__ENV.VUS || "1");
const ITERS    = Number((__ENV.ITERS || __ENV.ITER || "0").toString());
const DURATION = String(__ENV.DURATION || "30s");

// ---------- options ----------
export const options = ITERS > 0 ? {
  scenarios: {
    by_iter: { executor: "per-vu-iterations", vus: VUS, iterations: ITERS, maxDuration: "10m" }
  }
} : {
  scenarios: {
    by_time: { executor: "constant-vus", vus: VUS, duration: DURATION, gracefulStop: "3s" }
  }
};

// ---------- build endpoints ----------
function isPO(x){return x && typeof x==="object" && !Array.isArray(x);}
const SELECTED = FEAT_RAW ? FEAT_RAW.split(",").map(s=>s.trim()).filter(Boolean) : [];
console.log("parsed  -> vus=%s, iters=%s, duration=%s, features=%s",
  VUS, ITERS, DURATION, SELECTED.length?SELECTED.join("|"):"(all)");

const ENDPOINTS = [];
if (!isPO(features)) {
  console.error("features export invalid; typeof =", typeof features);
} else {
  const names = SELECTED.length ? SELECTED : Object.keys(features);
  for (const fname of names) {
    const list = features[fname];
    if (!Array.isArray(list)) { console.warn("feature not found / not array:", fname); continue; }
    for (const ep of list) {
      if (!isPO(ep)) continue;
      const method = String(ep.method || "GET").toUpperCase();
      const url    = String(ep.url || "");
      if (!url) { console.warn("skip empty url in", fname); continue; }
      ENDPOINTS.push({
        feature: fname,
        name: ep.name || (method + " " + url),
        method, url,
        headers: isPO(ep.headers)?ep.headers:undefined,
        auth: ep.auth || null
      });
    }
  }
}
console.log("endpoints built:", ENDPOINTS.length);
if (ENDPOINTS.length) console.log("first endpoint:", JSON.stringify(ENDPOINTS[0]));

// ---------- per-endpoint metric registry (works on k6 v0.46) ----------
function slug(s){
  return s.toLowerCase()
    .replace(/[^a-z0-9]+/g,"_")
    .replace(/^_+|_+$/g,"")
    .slice(0,120);
}
const REGISTRY = [];
const META_BY_LAT = {};  // metricName -> { feature, endpoint }
const META_BY_CNT = {};

for (const ep of ENDPOINTS) {
  const id = slug(ep.feature + "__" + ep.name);
  const latName = `lat_ep_${id}`;
  const cntName = `req_ep_${id}`;
  const lat = new Trend(latName, true);
  const cnt = new Counter(cntName);
  REGISTRY.push({ id, feature: ep.feature, endpoint: ep.name, latName, cntName });
  META_BY_LAT[latName] = { feature: ep.feature, endpoint: ep.name };
  META_BY_CNT[cntName] = { feature: ep.feature, endpoint: ep.name };
}

// ---------- tiny RR picker ----------
let idx = 0;
function pickEP(){ if (!ENDPOINTS.length) return null; const ep = ENDPOINTS[idx % ENDPOINTS.length]; idx = (idx+1)>>>0; return ep; }

// ---------- VU code ----------
export default function () {
  const ep = pickEP();
  if (!ep) { sleep(0.25); return; }

  const params = {};
  if (ep.headers) params.headers = ep.headers;
  if (ep.auth) {
    const h = params.headers || {};
    h.authorization = String(ep.auth);
    params.headers = h;
  }

  const t0 = Date.now();
  let res;
  try {
    if (ep.method === "GET") {
      res = http.get(ep.url, params);
    } else {
      res = http.request(ep.method, ep.url, null, params);
    }
  } catch (e) {
    console.error("request error:", String(e && e.message || e));
  }
  const dur = Date.now() - t0;
  const status = res ? res.status : 0;

  // record to this endpoint's dedicated metrics
  const id = slug(ep.feature + "__" + ep.name);
  const latName = `lat_ep_${id}`;
  const cntName = `req_ep_${id}`;
  // metric instances are looked up by name automatically by k6 when adding:
  Trend.prototype.add.call({ name: latName }, dur);   // safe on 0.46
  Counter.prototype.add.call({ name: cntName }, 1);

  console.log("[" + ep.feature + "] " + ep.name + " -> status=" + status + " dur=" + dur + "ms");
  sleep(0.2);
}

// ---------- summary ----------
export function handleSummary(data) {
  const metrics = (data && data.metrics) || {};
  const perEp = [];
  const perFeat = {};

  // consume our known metric names (created above)
  for (let i=0;i<REGISTRY.length;i++){
    const r = REGISTRY[i];
    const lat = metrics[r.latName];
    const cnt = metrics[r.cntName];
    const count = (cnt && cnt.values && (cnt.values.count || 0)) || 0;
    const avg = (lat && lat.values && typeof lat.values.avg === "number") ? Math.round(lat.values.avg) : 0;

    perEp.push([r.feature, r.endpoint, count, avg ? (avg + " ms") : "-"]);

    if (!perFeat[r.feature]) perFeat[r.feature] = { feature: r.feature, count: 0, sum: 0 };
    perFeat[r.feature].count += count;
    perFeat[r.feature].sum   += (avg * count);
  }

  const featRows = [];
  for (const f in perFeat){
    const obj = perFeat[f];
    const avg = obj.count ? Math.round(obj.sum / obj.count) : 0;
    featRows.push([obj.feature, obj.count, avg ? (avg + " ms") : "-"]);
  }

  function table(rows, headers) {
    let html = '<table style="border-collapse:collapse;width:100%;margin:10px 0">';
    html += "<tr>";
    for (let i=0;i<headers.length;i++){
      html += '<th style="text-align:left;padding:6px;border-bottom:1px solid #ddd">' + headers[i] + "</th>";
    }
    html += "</tr>";
    for (let r=0;r<rows.length;r++){
      html += "<tr>";
      const row = rows[r];
      for (let c=0;c<row.length;c++){
        html += '<td style="padding:6px;border-bottom:1px solid #f0f0f0">' + row[c] + "</td>";
      }
      html += "</tr>";
    }
    html += "</table>";
    return html;
  }

  let html  = "<!doctype html><meta charset='utf-8'><title>SDLC Auto Gov Load Test</title>";
  html += "<div style='font:14px/1.4 system-ui,Segoe UI,Arial'>";
  html += "<h2>SDLC Auto Gov Load Test â€” " + new Date().toISOString().replace("T"," ").slice(0,19) + "</h2>";
  const scenarioNames = Object.keys((data && data.options && data.options.scenarios) ? data.options.scenarios : {});
  html += "<div><b>Scenarios</b>: " + (scenarioNames.length ? scenarioNames.join(", ") : "-") + "</div>";

  html += "<h3 style='margin-top:18px'>Feature breakdown</h3>";
  html += featRows.length ? table(featRows, ["Feature","Requests","Avg latency"]) : "<i>No feature data recorded.</i>";

  html += "<h3 style='margin-top:18px'>Endpoint breakdown</h3>";
  html += perEp.length ? table(perEp, ["Feature","Endpoint","Requests","Avg latency"]) : "<i>No endpoint data recorded.</i>";

  html += "<details style='margin-top:18px'><summary>Raw JSON (truncated)</summary>";
  const raw = { options:data.options, metrics:{} };
  for (let i=0;i<REGISTRY.length;i++){
    const r = REGISTRY[i];
    raw.metrics[r.latName] = metrics[r.latName] || null;
    raw.metrics[r.cntName] = metrics[r.cntName] || null;
  }
  let json = JSON.stringify(raw, null, 2);
  if (json.length > 8000) json = json.slice(0,8000) + "\n...truncated...";
  html += "<pre style='white-space:pre-wrap;font:12px/1.4 ui-monospace,Consolas,monospace'>" + json.replace(/</g,"&lt;") + "</pre>";
  html += "</details></div>";

  // also keep full k6 JSON for debugging
  return {
    "perf/k6/reports/summary.json": JSON.stringify(data, null, 2),
    "perf/k6/reports/summary.html": html
  };
}
