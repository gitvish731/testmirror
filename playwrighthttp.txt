import http from "k6/http";
import { sleep, check, Trend, Counter } from "k6";
import features from "../sources/endpoints.byFeature.js";
export { handleSummary } from "../vendor/handleSummary.js"; // import only

// ---------- env parsing ----------
var FEAT_RAW = (__ENV.FEATURES || "").toString().trim();
var VUS      = Number(__ENV.VUS || "1");
var ITERS    = Number((__ENV.ITERS || __ENV.ITER || "0").toString());
var DURATION = (__ENV.DURATION || "30s").toString();

var SELECTED = FEAT_RAW
  ? FEAT_RAW.split(",").map(function (s) { return s.trim(); }).filter(function (s) { return s.length; })
  : [];

console.log(
  "parsed -> vus=" + VUS +
  ", iters=" + ITERS +
  ", duration=" + DURATION +
  ", features=" + (SELECTED.length ? SELECTED.join("|") : "(all)")
);

// ---------- executor selection ----------
export var options = ITERS > 0 ? {
  scenarios: { by_iter: { executor: "per-vu-iterations", vus: VUS, iterations: ITERS, maxDuration: "10m" } }
} : {
  scenarios: { by_time: { executor: "constant-vus", vus: VUS, duration: DURATION, gracefulStop: "3s" } }
};
console.log("executor chosen -> " + (ITERS > 0 ? "per-vu-iterations" : "constant-vus"));

// ---------- normalize features -> endpoints (defensive) ----------
function isPO(x) { return x && typeof x === "object" && !Array.isArray(x); }

var ENDPOINTS = [];
if (!isPO(features)) {
  console.error("features export invalid; got:", typeof features);
} else {
  var available = Object.keys(features);
  console.log("features available:", JSON.stringify(available));

  var names = SELECTED.length ? SELECTED : available;
  for (var i = 0; i < names.length; i++) {
    var fname = names[i];
    var list = features[fname];

    if (!Array.isArray(list)) {
      console.warn("Feature name not found or has no endpoints:", fname);
      list = []; // make it safe; keep going
    }

    for (var j = 0; j < list.length; j++) {
      var ep = list[j];
      if (!isPO(ep)) continue;

      var method = (ep.method || "GET").toUpperCase();
      var url = String(ep.url || "");
      if (!url) continue;

      var expect = isPO(ep.expect) ? ep.expect : {};
      ENDPOINTS.push({
        feature: fname,
        name: ep.name || (method + " " + url),
        method: method,
        url: url,
        expect: {
          status: Number(expect.status || 200),
          text: typeof expect.text === "string" ? expect.text : ""
        },
        headers: isPO(ep.headers) ? ep.headers : undefined,
        auth: ep.auth || null
      });
    }
  }
}

var latency_ep = new Trend("latency_ep");
var reqs_ep = new Counter("reqs_ep");

// ---------- main test ----------
export default function () {
  if (!ENDPOINTS.length) { sleep(0.2); return; }

  // round-robin across defined endpoints
  var idx = (typeof __ITER === "number" ? __ITER : 0) % ENDPOINTS.length;
  var ep = ENDPOINTS[idx];

  var tags = { feature: ep.feature, endpoint: ep.name };
  var params = { tags: tags };
  if (ep.headers) params.headers = ep.headers;
  if (ep.auth) {
    var h = params.headers || {};
    h.authorization = String(ep.auth);
    params.headers = h;
  }

  var res;
  switch (ep.method) {
    case "POST": res = http.post(ep.url, ep.body || "", params); break;
    case "PUT":  res = http.put(ep.url, ep.body || "", params);  break;
    case "PATCH":res = http.patch(ep.url, ep.body || "", params);break;
    case "DELETE": res = http.del(ep.url, null, params); break;
    default:     res = http.get(ep.url, params);
  }

  check(res, {
    "status ok": function (r) { return r && r.status === ep.expect.status; },
    "body has text": function (r) {
      if (!ep.expect.text) return true;
      var s = typeof r.body === "string" ? r.body : JSON.stringify(r.body);
      return s.indexOf(ep.expect.text) !== -1;
    }
  });

  latency_ep.add(res.timings.duration, tags);
  reqs_ep.add(1, tags);

  sleep(0.2);
}
