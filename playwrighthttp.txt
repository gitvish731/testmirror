// perf/k6/scenarios/from-playwright.http.min.js
// Minimal runner (k6 v0.46 compatible) + vendor handleSummary + feature/endpoint tagging

import http from 'k6/http';
import { sleep, check } from 'k6';
import features from '../sources/endpoints.byFeature.js';
import handleSummary from '../vendor/handleSummary.js'; // <— use the enhanced summary

// ---------- ENV / CLI switches ----------
// Examples:
//   k6 run perf/k6/scenarios/from-playwright.http.min.js -e VUS=2 -e ITER=2 -e FEATURES='ReportingAPI Alpha1' -e ENV=uat
//   k6 run perf/k6/scenarios/from-playwright.http.min.js -e VUS=2 -e DURATION=10s -e FEATURES='ReportingAPI Alpha1' -e ENV=uat
const RAW_FEATURES = (__ENV.FEATURES || '').trim();
const SELECTED_FEATURES = RAW_FEATURES
  ? RAW_FEATURES.split(',').map(s => s.trim()).filter(Boolean)
  : Object.keys(features); // default: all feature keys

const VUS = Number(__ENV.VUS || '1');
const ITER = __ENV.ITER ? Number(__ENV.ITER) : null;
const DURATION = (__ENV.DURATION || '').trim(); // e.g. "10s"

// Optional base URL/env tweak (no-op unless you want to use it in URLs)
const ENV = (__ENV.ENV || '').trim(); // "uat" | "dev" | etc.

// ---------- Build endpoint list from features map ----------
/*
Expected shape in ../sources/endpoints.byFeature.js:
export default {
  "ReportingAPI Alpha1": [
    {
      name: "Lists SBC compliances for all found Release Registrations",
      method: "GET",
      url: "https://grafeas.sdlcapis-test.azpriv-cloud.ubs.net/v1alpha1/compliances",
      headers: null,          // optional
      auth: null,             // optional, e.g. "bearer"
      expect: { status: 200, text: "releaseTagStatus" } // text optional
    }
  ]
}
*/
const ENDPOINTS = [];
for (let i = 0; i < SELECTED_FEATURES.length; i += 1) {
  const fname = SELECTED_FEATURES[i];
  const eps = features[fname];
  if (!eps || !Array.isArray(eps)) {
    console.warn(`[WARN] feature "${fname}" not found or has no endpoints`);
    continue;
  }
  for (let j = 0; j < eps.length; j += 1) {
    const ep = eps[j];
    ENDPOINTS.push({ feature: fname, ep });
  }
}

console.info(`features loaded: ${JSON.stringify(SELECTED_FEATURES)}`);
console.info(`endpoints built: ${ENDPOINTS.length}`);

// ---------- k6 options (choose executor based on what you passed) ----------
let scenarios;
if (ITER && !DURATION) {
  // run a fixed number of iterations per VU
  scenarios = {
    by_iter: {
      executor: 'per-vu-iterations',
      vus: VUS,
      iterations: ITER,
      maxDuration: '10m', // safety net
    },
  };
} else if (!ITER && DURATION) {
  // run for a duration at constant VUs
  scenarios = {
    by_time: {
      executor: 'constant-vus',
      vus: VUS,
      duration: DURATION,
      gracefulStop: '30s',
    },
  };
} else if (ITER && DURATION) {
  // both provided — honor ITER (explicit), ignore duration
  scenarios = {
    by_iter: {
      executor: 'per-vu-iterations',
      vus: VUS,
      iterations: ITER,
      maxDuration: DURATION || '10m',
    },
  };
} else {
  // nothing provided — smallest sensible default
  scenarios = {
    by_iter: {
      executor: 'per-vu-iterations',
      vus: 1,
      iterations: 1,
      maxDuration: '10m',
    },
  };
}

export const options = {
  scenarios,
  // show p(95) and avg in console & summary.json
  summaryTrendStats: ['avg', 'min', 'max', 'p(90)', 'p(95)'],
};

// ---------- tiny helper ----------
function hasText(body, mustContain) {
  if (!mustContain) return true;
  const s = typeof body === 'string' ? body : String(body || '');
  return s.indexOf(mustContain) !== -1;
}

// ---------- the test ----------
export default function () {
  if (ENDPOINTS.length === 0) {
    console.warn('No endpoints to run; sleeping this iteration.');
    sleep(0.2);
    return;
  }

  // For this minimal runner: hit every endpoint once per iteration
  for (let i = 0; i < ENDPOINTS.length; i += 1) {
    const { feature, ep } = ENDPOINTS[i];
    const method = (ep.method || 'GET').toUpperCase();
    const url = ep.url;
    const headers = ep.headers || null;

    let res;
    if (method === 'GET') {
      res = http.get(url, { headers, tags: { feature, endpoint: ep.name } });
    } else if (method === 'DELETE') {
      res = http.del(url, null, { headers, tags: { feature, endpoint: ep.name } });
    } else if (method === 'PATCH') {
      // if your ep has a body, include ep.body; otherwise send empty object
      res = http.patch(url, ep.body || {}, { headers, tags: { feature, endpoint: ep.name } });
    } else if (method === 'POST') {
      res = http.post(url, ep.body || {}, { headers, tags: { feature, endpoint: ep.name } });
    } else if (method === 'PUT') {
      res = http.put(url, ep.body || {}, { headers, tags: { feature, endpoint: ep.name } });
    } else {
      console.warn(`Unsupported method: ${method} for ${ep.name}`);
      continue;
    }

    const expect = ep.expect || {};
    check(res, {
      'status ok': (r) => (!expect.status ? r.status >= 200 && r.status < 400 : r.status === expect.status),
      'body has text': (r) => hasText(r.body, expect.text),
    }, { feature, endpoint: ep.name });

    // very short wait between endpoints (keeps output readable)
    sleep(0.1);
  }
}

// ---------- export the enhanced summary from vendor ----------
export { handleSummary };
