import http from 'k6/http';
import { check, sleep } from 'k6';
import { Trend, Counter } from 'k6/metrics';
import summaryRenderer from '../vendor/handleSummary.js';
import ENDPOINTS_BY_FEATURE_RAW from '../sources/endpoints.byFeature.js';

export function handleSummary(data) { return summaryRenderer(data); }

/* ----------------- helpers ----------------- */
const toInt = (v, d) => {
  const n = parseInt(v, 10);
  return Number.isNaN(n) ? d : n;
};
const norm = (s) => String(s || '').trim();
const has = (s) => norm(s).length > 0;

// k6 metric names must be ASCII letters, numbers and underscores.
// Make a stable, short slug we can use in metric names.
function slug(s) {
  return norm(s)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
    .slice(0, 60);
}

// optional ENV host tweak: only switch -test.â†’-dev. when ENV=dev
const ENV_NAME = norm(__ENV.ENV).toLowerCase();
function applyEnvToUrl(url) {
  if (ENV_NAME === 'dev') return String(url || '').replace('-test.', '-dev.');
  return url;
}

/* --------------- flexible run controls --------------- */
const ONE = __ENV.ONE === '1';
const VUS = toInt(__ENV.VUS, 0);
const ITER = toInt(__ENV.ITER, 0);
const DURATION = norm(__ENV.DURATION);
const FEATURES_RAW = norm(__ENV.FEATURES);
const ENDPOINT_FILTER = norm(__ENV.ENDPOINT_FILTER);

export const options =
  ONE
    ? { scenarios: { oneshot: { executor: 'per-vu-iterations', vus: 1, iterations: 1, maxDuration: '5m' } } }
    : (ITER > 0
        ? { scenarios: { iter: { executor: 'per-vu-iterations', vus: VUS > 0 ? VUS : 1, iterations: ITER, maxDuration: '30m' } } }
        : (has(DURATION)
            ? { scenarios: { run: { executor: 'constant-vus', vus: VUS > 0 ? VUS : 1, duration: DURATION, gracefulStop: '30s' } } }
            : { scenarios: { def: { executor: 'constant-vus', vus: 1, duration: '30s', gracefulStop: '30s' } } }));

/* --------------- pick endpoints --------------- */
function loadEndpoints() {
  const MAP = ENDPOINTS_BY_FEATURE_RAW || {};
  const list = has(FEATURES_RAW) ? FEATURES_RAW.split(/[,\n]/).map(s => s.trim()).filter(Boolean) : Object.keys(MAP);
  const selected = [];

  for (let i = 0; i < list.length; i++) {
    const feature = list[i];
    const arr = MAP[feature] || [];
    for (let j = 0; j < arr.length; j++) {
      const ep = arr[j];
      if (!has(ENDPOINT_FILTER) || String(ep.name || '').toLowerCase().includes(ENDPOINT_FILTER.toLowerCase())) {
        selected.push({ feature, ep });
      }
    }
  }
  if (!selected.length) throw new Error('No endpoints found for FEATURES="' + list.join(', ') + '"');
  console.log(`INFO selected ${selected.length} endpoint(s) across FEATURES: ${list.join(' | ')}`);
  return selected;
}
const SELECTED = loadEndpoints();

/* --------------- metrics --------------- */
// 1) tagged (ideal path if your k6 shows submetrics in summary)
const reqs_ep = new Counter('reqs_ep');
const latency_ep = new Trend('latency_ep', true);

// 2) per-endpoint metric names (fallback that always appears in summary)
const perMetric = new Map();
function getPerMetrics(feature, endpointName) {
  const key = `${feature}::${endpointName}`;
  let pair = perMetric.get(key);
  if (!pair) {
    const f = slug(feature);
    const e = slug(endpointName);
    pair = {
      c: new Counter(`ep_reqs_${f}__${e}`),
      t: new Trend(`ep_lat_${f}__${e}`, true),
    };
    perMetric.set(key, pair);
  }
  return pair;
}

function buildHeaders(method) {
  let base = {
    accept: 'application/json',
    'content-type': 'application/json',
    'user-agent': 'k6:auto-runner',
  };
  if (has(__ENV.HEADERS_JSON)) {
    try {
      Object.assign(base, JSON.parse(__ENV.HEADERS_JSON));
    } catch (e) {
      console.error('WARN HEADERS_JSON invalid JSON:', e && e.message);
    }
  }
  return base;
}

/* --------------- main --------------- */
export default function () {
  // 1 "iteration" = run each selected endpoint once
  for (let i = 0; i < SELECTED.length; i++) {
    const feature = SELECTED[i].feature;
    const ep = SELECTED[i].ep;

    const method = String(ep.method || 'GET').toUpperCase();
    const url = applyEnvToUrl(ep.url || ep.uri || ep.href || '');
    const expected = ep.expect && typeof ep.expect.status !== 'undefined' ? Number(ep.expect.status) : 200;
    const mustContain = ep.expect && has(ep.expect.text) ? String(ep.expect.text) : null;

    const endpointName = String(ep.name || `${method} ${url}`);
    const tags = { feature, endpoint: endpointName };
    const headers = buildHeaders(method);

    let res;
    if (method === 'GET') {
      res = http.get(url, { headers, tags });
    } else if (method === 'POST') {
      const body = (ep.body && typeof ep.body === 'object') ? JSON.stringify(ep.body) : (ep.body || '');
      res = http.post(url, body, { headers, tags });
    } else if (method === 'PUT' || method === 'PATCH' || method === 'DELETE') {
      const body2 = (ep.body && typeof ep.body === 'object') ? JSON.stringify(ep.body) : (ep.body || '');
      res = http.request(method, url, body2, { headers, tags });
    } else {
      res = http.request(method, url, null, { headers, tags });
    }

    // A) tagged metrics (for reporters that read submetrics)
    reqs_ep.add(1, tags);
    latency_ep.add(res.timings.duration, tags);

    // B) per-endpoint concrete metrics (always present in summary)
    const pm = getPerMetrics(feature, endpointName);
    pm.c.add(1);
    pm.t.add(res.timings.duration);

    // checks (tagged)
    check(res, {
      'status ok': r => r.status === expected,
      'body has text': r => (mustContain ? String(r.body || '').indexOf(mustContain) !== -1 : true),
    }, tags);

    if (!ONE) sleep(0.2);
  }
}
