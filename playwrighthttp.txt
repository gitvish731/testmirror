// perf/k6/scenarios/from-playwright.http.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { open } from 'k6/io';
export { handleSummary } from '../vendor/handleSummary.js'; // writes perf/k6/reports/summary.html

// ---------- ENV / Defaults ----------
const ENV            = (__ENV.ENV || 'dev').toLowerCase();                        // dev | uat
const FEATURES_RAW   = __ENV.FEATURES || '';                                       // "ReportingAPI Alpha1, DeploymentAPI"
const ENDPOINT_FILTER= __ENV.ENDPOINT_FILTER || '';                                // substring or regex-like; optional
const BASE_URL       = (__ENV.BASE_URL || '').trim();                              // optional hard override
const TOKEN          = (__ENV.TOKEN || '').trim();                                 // bearer for POST/PATCH/DELETE only
const DURATION       = __ENV.DURATION || '30s';
const RPS            = Number(__ENV.RPS || '1');
const PREALLOC       = Number(__ENV.PREALLOC || '6');
const MAXVUS         = Number(__ENV.MAXVUS || '40');
const THRESHOLDS_ON  = (__ENV.THRESHOLDS || 'true').toLowerCase() !== 'false';
const EP_RATES       = safeJson(__ENV.EP_RATES) || {};                             // { "feature": { "Endpoint Name": 3, ... }, ... }

// ---------- Load Endpoints JSON (generated by the script) ----------
const EP_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));     // { "Feature": [ {name,method,url,auth?,headers?,body?,expect?} ] }

// ---------- Feature / endpoint selection ----------
const SELECTED_FEATURES = normalizeList(FEATURES_RAW);                              // [] means "all"
const allFeatures = Object.keys(EP_BY_FEATURE);
const pickedFeatures = SELECTED_FEATURES.length ? allFeatures.filter(f => SELECTED_FEATURES.includes(f)) : allFeatures;

// Flatten endpoints with feature context
let ENDPOINTS = [];
for (const feature of pickedFeatures) {
  const list = (EP_BY_FEATURE[feature] || []).filter(ep => matchesFilter(ep.name, ENDPOINT_FILTER));
  for (const ep of list) ENDPOINTS.push({ feature, ...ep });
}
if (ENDPOINTS.length === 0) {
  console.log(`No endpoints selected. Check FEATURES="${FEATURES_RAW}" and ENDPOINT_FILTER="${ENDPOINT_FILTER}".`);
}

// ---------- URL handling (preserve full URLs; switch dev/uat if requested) ----------
function withEnvHost(url) {
  try {
    // If caller supplied BASE_URL, and url is relative -> prepend.
    if (BASE_URL && !/^\w+:\/\//.test(url)) {
      const a = new URL(BASE_URL.replace(/\/+$/,'') + '/' + url.replace(/^\/+/,''));
      return a.toString();
    }
    const u = new URL(url, BASE_URL || 'http://placeholder'); // supports absolute or relative
    // Only switch when a host exists (absolute URL); relative will be resolved by BASE_URL above.
    if (/^\w+:\/\//.test(url)) {
      if (ENV === 'dev') {
        u.hostname = u.hostname.replace(/-test(\.|-)/, '-dev$1');
      } else if (ENV === 'uat') {
        u.hostname = u.hostname.replace(/-dev(\.|-)/, '-test$1');
      }
    }
    return u.toString();
  } catch (_) {
    // As a last resort, just join BASE_URL and url if possible
    if (BASE_URL) return BASE_URL.replace(/\/+$/,'') + '/' + String(url).replace(/^\/+/,'');
    return url;
  }
}

// ---------- Scenarios (constant-arrival-rate per endpoint) ----------
const scenarios = {};
ENDPOINTS.forEach((ep, i) => {
  const rate = (EP_RATES[ep.feature] && EP_RATES[ep.feature][ep.name]) || RPS;
  scenarios[`ep_${i}`] = {
    executor: 'constant-arrival-rate',
    rate,                            // iters/sec for this endpoint
    timeUnit: '1s',
    duration: DURATION,
    preAllocatedVUs: PREALLOC,
    maxVUs: MAXVUS,
    exec: `exec_ep_${i}`,
    tags: { feature: ep.feature, endpoint: ep.name, method: ep.method }
  };
  // Install a dedicated exec function for each endpoint
  globalThis[`exec_ep_${i}`] = function () { runOne(ep); };
});

// ---------- Thresholds (soft locally by default) ----------
const thresholds = THRESHOLDS_ON ? {
  http_req_failed:   [{ threshold: 'rate<0.05',   abortOnFail: false }], // warn if >5% errors
  http_req_duration: [{ threshold: 'p(95)<60000', abortOnFail: false }],
} : {};

export const options = { scenarios, thresholds };

// ---------- Runner ----------
function runOne(ep) {
  const url  = withEnvHost(ep.url || ep.path || ep.unified_string || '');
  const tags = { feature: ep.feature, endpoint: ep.name, method: ep.method };

  // Build headers per rules
  const hdrs = {};
  // For non-GET, caller requires content-type + token
  const needsAuth = /^(POST|PUT|PATCH|DELETE)$/i.test(ep.method || '');
  if (needsAuth) {
    hdrs['Content-Type'] = 'application/json';
    if (TOKEN) hdrs['Authorization'] = `Bearer ${TOKEN}`;
  }

  let res;
  const method = (ep.method || 'GET').toUpperCase();
  try {
    if (method === 'GET') {
      res = http.get(url, { tags });
    } else if (method === 'POST') {
      res = http.post(url, cleanBody(ep.body), { headers: hdrs, tags });
    } else if (method === 'PUT') {
      res = http.put(url, cleanBody(ep.body), { headers: hdrs, tags });
    } else if (method === 'PATCH') {
      res = http.patch(url, cleanBody(ep.body), { headers: hdrs, tags });
    } else if (method === 'DELETE') {
      // Some DELETEs send a body; send if present
      const body = cleanBody(ep.body);
      res = body ? http.del(url, body, { headers: hdrs, tags }) : http.del(url, null, { headers: hdrs, tags });
    } else {
      // Fallback as GET
      res = http.get(url, { tags });
    }
  } catch (e) {
    // network error still gets measured via http_req_failed
    console.error(`Request error for ${ep.feature} :: ${ep.name} -> ${e}`);
    return;
  }

  // Checks: status (always) + optional text substring
  const expectStatus = ep.expect && ep.expect.status ? Number(ep.expect.status) : 200;
  const expectText   = ep.expect && ep.expect.text ? String(ep.expect.text) : null;

  const statusOk = check(res, { 'status ok': (r) => r.status === expectStatus }, tags);
  if (expectText) {
    check(res, { 'body has text': (r) => (r.body || '').indexOf(expectText) !== -1 }, tags);
  }

  // brief think-time to mimic PW tests a little
  sleep(0.1);

  // Optional debug
  // if (!statusOk) console.log(`DEBUG ${ep.feature} :: ${ep.name} :: ${method} ${url} -> ${res.status} body=${(res.body||'').slice(0,200)}`);
}

// ---------- Helpers ----------
function cleanBody(body) {
  if (body == null) return null;
  if (typeof body === 'string') return body.trim();
  try { return JSON.stringify(body); } catch { return String(body); }
}
function normalizeList(s) {
  return String(s || '')
    .split(',')
    .map(x => x.trim())
    .filter(Boolean);
}
function matchesFilter(name, filter) {
  if (!filter) return true;
  // simple contains or /regex/ support
  const f = String(filter).trim();
  if (f.startsWith('/') && f.endsWith('/')) {
    try { return new RegExp(f.slice(1, -1), 'i').test(name); } catch { return name.toLowerCase().includes(f.slice(1, -1).toLowerCase()); }
  }
  return name.toLowerCase().includes(f.toLowerCase());
}
function safeJson(s) {
  try { return s ? JSON.parse(s) : null; } catch { return null; }
}
