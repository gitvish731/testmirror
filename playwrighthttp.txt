// ESM entry (k6 v0.46 OK)
// Emits per-endpoint metrics that handleSummary.js will read.

import http from 'k6/http';
import { sleep, check, Trend, Counter } from 'k6';
import featuresMap from '../sources/endpoints.byFeature.js';
import hs from '../vendor/handleSummary.js';

// === k6 picks up this named export ===
export const handleSummary = hs;

// ---- CLI env parsing (VUS / ITERS / DURATION / FEATURES) ----
const RAW_VUS       = String(__ENV.VUS || '1');
const RAW_ITERS     = String(__ENV.ITERS || '1');
const RAW_DURATION  = String(__ENV.DURATION || '0s');   // "0s" -> per-vu-iterations
const RAW_FEATURES  = String(__ENV.FEATURES || '').trim();

const VUS       = Number(RAW_VUS) || 1;
const ITERS     = Number(RAW_ITERS) || 1;
const DURATION  = RAW_DURATION;
const FEATURES  = RAW_FEATURES ? RAW_FEATURES.split(',').map(s => s.trim()).filter(Boolean) : Object.keys(featuresMap);

// ---- choose executor based on presence of duration ----
const USE_DURATION = /^(\d+)(ms|s|m|h)$/.test(DURATION) && !/^0s$/.test(DURATION);

// ---- small helpers ----
const slug = (s) =>
  String(s || '')
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[^\w\s-]/g, '')     // strip non-word
    .replace(/\s+/g, '_')         // spaces -> underscore
    .replace(/_+/g, '_')
    .slice(0, 80) || 'unnamed';

const metricCache = new Map();
function pairFor(featureName, epName) {
  const epSlug = slug(`${featureName}__${epName}`);
  if (!metricCache.has(epSlug)) {
    // Create once per endpoint; names must be ASCII and unique
    metricCache.set(epSlug, {
      cnt: new Counter(`reqs_ep__${epSlug}`),
      lat: new Trend(`lat_ep__${epSlug}`),
    });
  }
  return metricCache.get(epSlug);
}

// ---- build endpoint list from selected features ----
function buildEndpoints() {
  const selected = [];
  for (const fname of FEATURES) {
    const group = featuresMap[fname];
    if (!Array.isArray(group)) continue;
    for (const ep of group) {
      // minimal shape: { name, method, url, expect:{status?, text?}, headers?, auth? }
      const item = {
        feature: fname,
        name: ep.name || ep.url,
        method: (ep.method || 'GET').toUpperCase(),
        url: ep.url,
        expect: ep.expect || {},
        headers: ep.headers || null,
        auth: ep.auth || null,
      };
      selected.push(item);
    }
  }
  return selected;
}

const ENDPOINTS = buildEndpoints();
console.log(`features available: ${JSON.stringify(FEATURES)}`);
console.log(`endpoints built: ${ENDPOINTS.length}`);

// ---- k6 options ----
export const options = USE_DURATION
  ? {
      scenarios: {
        by_time: {
          executor: 'constant-vus',
          vus: VUS,
          duration: DURATION,
          gracefulStop: '3s',
        },
      },
    }
  : {
      scenarios: {
        by_iter: {
          executor: 'per-vu-iterations',
          vus: VUS,
          iterations: ITERS,          // per VU
          maxDuration: '10m',
          gracefulStop: '30s',
        },
      },
    };

// ---- test loop ----
export default function () {
  for (const ep of ENDPOINTS) {
    const params = { headers: ep.headers || {} };
    // trivial bearer support if provided as ep.auth = 'bearer <token>'
    if (ep.auth && /^bearer\s+/i.test(ep.auth)) {
      params.headers = params.headers || {};
      params.headers.Authorization = ep.auth;
    }

    const t0 = Date.now();
    let res;

    try {
      switch (ep.method) {
        case 'POST':   res = http.post(ep.url, ep.body || null, params); break;
        case 'PUT':    res = http.put(ep.url, ep.body || null, params);  break;
        case 'PATCH':  res = http.patch(ep.url, ep.body || null, params);break;
        case 'DELETE': res = http.del(ep.url, null, params);             break;
        default:       res = http.get(ep.url, params);
      }
    } catch (e) {
      // network exception; still record as failed with a dummy latency
      const m = pairFor(ep.feature, ep.name);
      m.cnt.add(1);
      m.lat.add(0);
      console.error(`net error: ${ep.method} ${ep.url} :: ${String(e)}`);
      continue;
    }

    const ms = Date.now() - t0;
    const expect = ep.expect || {};
    const ok =
      (expect.status ? res.status === expect.status : res.status >= 200 && res.status < 400) &&
      (expect.text ? String(res.body || '').indexOf(expect.text) !== -1 : true);

    // normal k6 checks (optional)
    check(res, {
      'status ok': (r) => (expect.status ? r.status === expect.status : r.status >= 200 && r.status < 400),
      'body has text': (r) => (expect.text ? String(r.body || '').indexOf(expect.text) !== -1 : true),
    });

    // emit custom per-endpoint metrics that the summary will read
    const m = pairFor(ep.feature, ep.name);
    m.cnt.add(1);
    m.lat.add(ms);

    sleep(0.1);
  }
}
