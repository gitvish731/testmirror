/* perf/k6/scenarios/from-playwright.http.js */

import http from 'k6/http';
import { check, sleep } from 'k6';

/* Load generated endpoints map (JSON) */
const ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));

/* Wire CommonJS handleSummary (keep this require) */
const handleSummaryFn = require('../vendor/handleSummary.js');
export function handleSummary(data) {
  return handleSummaryFn(data);
}

/* Env knobs */
const ENV = __ENV || {};
const RUN_ENV = (ENV.env || ENV.ENV || '').toLowerCase();
const FEATURES_RAW = (ENV.FEATURES || ENV.features || '').trim();
const ENDPOINT_FILTER = (ENV.ENDPOINT_FILTER || '').trim();
const BASE_URL = (ENV.BASE_URL || '').trim();
const TOKEN = (ENV.token || ENV.TOKEN || ENV.GRAFEAS_LOGIN_TOKEN || '').trim();

const DURATION = ENV.DURATION || '30s';
const RPS = Number(ENV.RPS || 1);
const PREALLOC = Number(ENV.PREALLOC || 5);
const MAXVUS = Number(ENV.MAXVUS || 10);
const THRESHOLDS_ON = String(ENV.THRESHOLDS || 'true').toLowerCase() !== 'false';

/* Helpers */
function log() { try { console.log.apply(console, arguments); } catch (_) {} }

function normalizeFeatureName(name) {
  return String(name || '').trim();
}

function pickFeatures() {
  const all = Object.keys(ENDPOINTS_BY_FEATURE);
  if (!FEATURES_RAW) return all;
  const wanted = FEATURES_RAW.split(',').map((s) => normalizeFeatureName(s));
  return all.filter((f) => wanted.indexOf(f) !== -1);
}

function urlWithBase(url) {
  if (!BASE_URL) return url;
  try {
    const u = new URL(url);
    const b = new URL(BASE_URL);
    u.protocol = b.protocol;
    u.host = b.host;
    return u.toString();
  } catch (_) {
    return url;
  }
}

function headersFor(method) {
  const h = {};
  if (method !== 'GET') {
    if (TOKEN) h['Authorization'] = `Bearer ${TOKEN}`;
    h['Content-Type'] = 'application/json';
  }
  return h;
}

function shouldKeepEndpoint(ep) {
  if (!ENDPOINT_FILTER) return true;
  return String(ep.name || '').toLowerCase().indexOf(ENDPOINT_FILTER.toLowerCase()) !== -1;
}

/* Build selected endpoint list with feature context */
const SELECTED_FEATURES = pickFeatures();
const ENDPOINTS = [];
for (const feature of SELECTED_FEATURES) {
  const arr = ENDPOINTS_BY_FEATURE[feature] || [];
  for (const ep of arr) {
    if (shouldKeepEndpoint(ep)) ENDPOINTS.push({ feature, ep });
  }
}
log(`Selected ${ENDPOINTS.length} endpoint(s) across FEATURES: ${SELECTED_FEATURES.join(', ')}`);

/* Scenarios: one per endpoint, single exec */
const scenarios = {};
ENDPOINTS.forEach(({ feature, ep }, i) => {
  scenarios[`ep_${i}`] = {
    executor: 'constant-arrival-rate',
    exec: 'run',
    rate: RPS,
    timeUnit: '1s',
    duration: DURATION,
    preAllocatedVUs: PREALLOC,
    maxVUs: MAXVUS,
    gracefulStop: '30s',
    env: { EP_INDEX: String(i) },
    tags: { feature, endpoint: ep.name },
  };
});

/* Thresholds (optional) */
const thresholds = THRESHOLDS_ON
  ? {
      http_req_failed: ['rate<0.01'],
      http_req_duration: ['p(95)<60000'],
    }
  : {};

export const options = {
  scenarios,
  thresholds,
  summaryTrendStats: ['avg', 'med', 'min', 'max', 'p(90)', 'p(95)'],
};

/* Dispatcher */
export function run() {
  const idx = Number(__ENV.EP_INDEX || 0);
  const ctx = ENDPOINTS[idx];
  if (!ctx) return;

  const feature = ctx.feature;
  const ep = ctx.ep;

  const tags = { feature, endpoint: ep.name };
  const expectStatus = (ep.expect && ep.expect.status) || 200;
  const mustContain = ep.expect && ep.expect.text ? String(ep.expect.text) : null;

  const method = String(ep.method || 'GET').toUpperCase();
  const url = urlWithBase(String(ep.url || ''));
  const headers = headersFor(method);

  let res;
  switch (method) {
    case 'GET':
      res = http.get(url, { headers, tags });
      break;
    case 'POST':
      res = http.post(url, ep.body || null, { headers, tags });
      break;
    case 'PATCH':
      res = http.patch(url, ep.body || null, { headers, tags });
      break;
    case 'DELETE':
      res = http.del(url, null, { headers, tags });
      break;
    default:
      res = http.request(method, url, ep.body || null, { headers, tags });
      break;
  }

  // Build checks without object spread
  const checks = {
    'status ok': function (r) { return r.status === expectStatus; },
  };
  if (mustContain) {
    checks['body has text'] = function (r) {
      return String(r.body || '').indexOf(mustContain) !== -1;
    };
  }
  check(res, checks, tags);

  sleep(0.1);
}

/* EOF */
