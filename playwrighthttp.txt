// perf/k6/scenarios/from-playwright.http.js
// k6 v0.46 compatible (no object spread in check, no optional chaining)

import http from "k6/http";
import { sleep, check } from "k6";
import { Trend, Counter } from "k6/metrics";
import features from "../sources/endpoints.byFeature.js";     // <- your feature map (default export)

// If you DO have a summary helper, keep these two lines.
// If you DON'T have it, delete the next two lines.
import handleSummary from "../vendor/handleSummary.js";
export { handleSummary };

/**********************
 * ENV / CLI switches *
 **********************
 * -e FEATURES='ReportingAPI Alpha1, SomethingElse'
 * -e VUS=2             (# virtual users)
 * -e ITERS=2           (# iterations per VU; uses per-vu-iterations executor)
 * -e DURATION=30s      (uses constant-vus executor)
 * -e ONE=1             (shortcut: run exactly one iteration total)
 * -e TIER=dev|uat      (optional passthrough; does not alter URLs)
 */

const RAW_FEATURES = (__ENV.FEATURES || "").trim();
const VUS = toInt(__ENV.VUS, 1);
const ITERS = toInt(__ENV.ITERS, 0);
const ONE = toInt(__ENV.ONE, 0);
const DURATION = (__ENV.DURATION || "").trim();

const usePerVuIters = ONE === 1 || (ITERS > 0 && !DURATION);
const perVuIters = ONE === 1 ? 1 : Math.max(ITERS, 1);

export let options = usePerVuIters
  ? {
      scenarios: {
        by_iter: {
          executor: "per-vu-iterations",
          vus: Math.max(VUS, 1),
          iterations: perVuIters,
          maxDuration: "120s",
        },
      },
      thresholds: {
        http_req_failed: ["rate<0.05"],
      },
    }
  : {
      scenarios: {
        by_time: {
          executor: "constant-vus",
          vus: Math.max(VUS, 1),
          duration: DURATION || "30s",
          gracefulStop: "3s",
        },
      },
      thresholds: {
        http_req_failed: ["rate<0.05"],
      },
    };

/************************************
 * Custom per-endpoint metrics (tagged)
 ************************************/
const reqs_ep = new Counter("reqs_ep");            // counts requests per feature/endpoint
const latency_ep = new Trend("latency_ep", true);  // ms per feature/endpoint

/************************************
 * Build the endpoint execution list *
 ************************************/
const REQUESTED = RAW_FEATURES
  ? RAW_FEATURES.split(",").map(function (s) { return s.trim(); }).filter(function (v) { return v; })
  : Object.keys(features);

const SELECTED = REQUESTED.filter(function (n) {
  return Object.prototype.hasOwnProperty.call(features, n);
});
const MISSING = REQUESTED.filter(function (n) { return SELECTED.indexOf(n) === -1; });
if (MISSING.length) {
  console.error("Unknown feature(s) ignored:", MISSING);
}

const ENDPOINTS = [];
for (var i = 0; i < SELECTED.length; i++) {
  var fname = SELECTED[i];
  var eps = features[fname];
  if (!eps || Object.prototype.toString.call(eps) !== "[object Array]") {
    console.error("Feature does not map to an array of endpoints:", fname, eps);
    continue;
  }
  for (var j = 0; j < eps.length; j++) {
    var ep = eps[j] || {};
    if (!ep.url || !ep.method) {
      console.error("Bad endpoint definition under", fname, ep);
      continue;
    }
    ENDPOINTS.push({
      feature: fname,
      name: ep.name || ep.url,
      method: String(ep.method || "GET").toUpperCase(),
      url: ep.url,
      headers: ep.headers || {},
      auth: ep.auth || null,
      expect: ep.expect || { status: 200, text: null },
      body: ep.body || null,
    });
  }
}

if (!ENDPOINTS.length) {
  throw new Error(
    'No endpoints selected. FEATURES="' + RAW_FEATURES + '" | available=' + Object.keys(features).join(", ")
  );
}

console.log("features loaded:", JSON.stringify(SELECTED));

/*****************
 * Main iteration *
 *****************/
export default function () {
  var idx = (__ITER % ENDPOINTS.length);
  var ep = ENDPOINTS[idx];

  var tags = { feature: ep.feature, endpoint: ep.name };
  var params = {
    tags: tags,                       // critical: puts feature/endpoint tags on built-in metrics
    headers: buildHeaders(ep.headers, ep.auth),
  };

  var res;
  try {
    switch (ep.method) {
      case "GET":
        res = http.get(ep.url, params);
        break;
      case "POST":
        res = http.post(ep.url, ep.body || "", params);
        break;
      case "PATCH":
        res = http.patch(ep.url, ep.body || "", params);
        break;
      case "PUT":
        res = http.put(ep.url, ep.body || "", params);
        break;
      case "DELETE":
        res = http.del(ep.url, null, params);
        break;
      default:
        throw new Error("Unsupported method: " + ep.method);
    }
  } catch (e) {
    reqs_ep.add(1, tags);
    console.error("request error for", ep.name, e && (e.message || e));
    sleep(0.2);
    return;
  }

  // Emit custom metrics with tags
  reqs_ep.add(1, tags);
  if (res && res.timings && typeof res.timings.duration === "number") {
    latency_ep.add(res.timings.duration, tags);
  }

  // ---- v0.46-safe checks (no object spread) ----
  var expect = ep.expect || {};
  var checksObj = {};
  checksObj["status ok"] = function (r) {
    return r && r.status === (expect.status || 200);
  };
  if (expect.text) {
    checksObj["body has text"] = function (r) {
      var b = (r && r.body) ? String(r.body) : "";
      return b.indexOf(expect.text) !== -1;
    };
  }
  var ok = check(res, checksObj);
  if (!ok) {
    console.warn("check(s) failed for", ep.name, "status=", res && res.status);
  }

  sleep(0.2);
}

/**************
 * Utilities  *
 **************/
function toInt(v, defVal) {
  var n = parseInt(v, 10);
  return isNaN(n) ? defVal : n;
}

function buildHeaders(h, auth) {
  var hdrs = {};
  // shallow copy without spread
  for (var k in (h || {})) {
    if (Object.prototype.hasOwnProperty.call(h, k)) hdrs[k] = h[k];
  }
  if (hdrs["Content-Type"] && !hdrs["content-type"]) {
    hdrs["content-type"] = hdrs["Content-Type"];
  }
  if (auth && typeof auth === "string") {
    var parts = auth.trim().split(/\s+/, 2);
    if (parts.length === 2 && /^bearer$/i.test(parts[0])) {
      hdrs["Authorization"] = "Bearer " + parts[1];
    }
  }
  return hdrs;
}
