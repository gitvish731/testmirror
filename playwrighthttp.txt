rm -f perf/k6/sources/endpoints.byFeature.js
node -e "const fs=require('fs');const p='perf/k6/sources/endpoints.byFeature.json';const out='perf/k6/sources/endpoints.byFeature.js';const txt=fs.readFileSync(p,'utf8').trim();fs.writeFileSync(out,'module.exports = '+txt+';\\n');console.log('wrote',out)"


import http from 'k6/http';
import { check, sleep } from 'k6';

// -----------------------------------------------------------------------------
// 1️⃣ Load endpoints map (CommonJS wrapper first, JSON fallback)
// -----------------------------------------------------------------------------
let ENDPOINTS_BY_FEATURE;
try {
  ENDPOINTS_BY_FEATURE = require('../sources/endpoints.byFeature.js');
} catch (_) {
  ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));
}

// -----------------------------------------------------------------------------
// 2️⃣ Read environment variables
// -----------------------------------------------------------------------------
const ENV = (__ENV.ENV || 'dev').toLowerCase();
const BASE_URL = __ENV.BASE_URL || '';
const TOKEN = __ENV.TOKEN || '';
const FEATURES_RAW = String(__ENV.FEATURES || '').split(',').map(s => s.trim()).filter(Boolean);
const ENDPOINT_FILTER = String(__ENV.ENDPOINT_FILTER || '').trim() || null;

const DURATION = __ENV.DURATION || '30s';
const RPS = Number(__ENV.RPS || '1');
const PREALLOC = Number(__ENV.PREALLOC || '5');
const MAXVUS = Number(__ENV.MAXVUS || '40');

const THRESHOLDS_ON = (__ENV.THRESHOLDS_ON || 'false').toLowerCase() === 'true';

// -----------------------------------------------------------------------------
// 3️⃣ Feature & endpoint filtering
// -----------------------------------------------------------------------------
const allFeatures = Object.keys(ENDPOINTS_BY_FEATURE);
const SELECTED_FEATURES = FEATURES_RAW.length ? FEATURES_RAW : allFeatures;

const ENDPOINTS = [];
for (const feature of SELECTED_FEATURES) {
  const src = ENDPOINTS_BY_FEATURE[feature] || [];
  for (const ep of src) {
    if (!ENDPOINT_FILTER || String(ep.name).includes(ENDPOINT_FILTER)) {
      ENDPOINTS.push({ feature, ...ep });
    }
  }
}

console.log(
  `>> Selected ${ENDPOINTS.length} endpoint(s) across FEATURES=[${SELECTED_FEATURES.join(', ')}]` +
  (ENDPOINT_FILTER ? ` filter='${ENDPOINT_FILTER}'` : '')
);

// -----------------------------------------------------------------------------
// 4️⃣ Test options
// -----------------------------------------------------------------------------
export const options = {
  scenarios: Object.fromEntries(
    ENDPOINTS.map((ep, i) => [
      `ep_${i}`,
      {
        executor: 'constant-arrival-rate',
        rate: RPS,
        timeUnit: '1s',
        duration: DURATION,
        preAllocatedVUs: PREALLOC,
        maxVUs: MAXVUS,
        exec: `ep_${i}`,
      },
    ])
  ),
  thresholds: THRESHOLDS_ON
    ? {
        http_req_failed: ['rate<0.01'],
        http_req_duration: ['p(95)<2000'],
      }
    : {},
};

// -----------------------------------------------------------------------------
// 5️⃣ Generate test functions dynamically for each endpoint
// -----------------------------------------------------------------------------
for (const [i, ep] of ENDPOINTS.entries()) {
  const fnName = `ep_${i}`;
  const tags = { feature: ep.feature, endpoint: ep.name };

  exports[fnName] = function () {
    const url = BASE_URL + ep.url;
    const params = { headers: { Authorization: `Bearer ${TOKEN}` }, tags };

    let res;
    switch (ep.method.toUpperCase()) {
      case 'GET':
        res = http.get(url, params);
        break;
      case 'POST':
        res = http.post(url, ep.body || '', params);
        break;
      case 'PATCH':
        res = http.patch(url, ep.body || '', params);
        break;
      case 'DELETE':
        res = http.del(url, null, params);
        break;
      default:
        console.warn(`Unsupported method: ${ep.method}`);
        return;
    }

    check(res, {
      'status ok': (r) => r.status >= 200 && r.status < 300,
      'body has text': (r) => r.body && r.body.length > 0,
    }, tags);

    sleep(1);
  };
}

