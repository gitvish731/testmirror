/* eslint-disable */
// k6 runner for API endpoints generated from Playwright specs (GET-focused)

/** k6 core */
const http = require('k6/http');
const { check, sleep } = require('k6');
const { Counter, Trend } = require('k6/metrics');

/** HTML report renderer (keep path relative to THIS file) */
const { handleSummary } = require('../vendor/handleSummary.js');

/** --- Config via env (with sensible defaults) --- */
const ENV = (__ENV.ENV || 'dev').toLowerCase();            // dev | uat | prod (free-form)
const FEATURES_RAW = (__ENV.FEATURES || '').trim();        // e.g. "ReportingAPI Alpha1, GrafanaSV1"
const ENDPOINT_FILTER = (__ENV.ENDPOINT_FILTER || '').trim(); // substring or regex, case-insensitive
const DURATION = __ENV.DURATION || '30s';
const RPS = Number(__ENV.RPS || 1);                        // overall arrival rate (default 1 rps)
const PREALLOC = Number(__ENV.PREALLOC || 5);
const MAXVUS = Number(__ENV.MAXVUS || 35);
const BASE_URL_OVERRIDE = (__ENV.BASE_URL || '').trim();   // optional http(s)://host[:port]
const TOKEN = (__ENV.TOKEN || '').trim();                  // optional bearer token

/** --- Load endpoints map (generated by your script) --- */
/** Use open() so it works inside k6 without bundling JSON */
function loadMap() {
  // path is relative to THIS file
  const raw = open('../sources/endpoints.byFeature.json');
  return JSON.parse(raw);
}
const ENDPOINTS_BY_FEATURE = loadMap();

/** --- Select features --- */
const ALL_FEATURES = Object.keys(ENDPOINTS_BY_FEATURE || {});
const SELECTED_FEATURES = FEATURES_RAW
  ? FEATURES_RAW.split(',').map(s => s.trim()).filter(Boolean)
  : ALL_FEATURES;

/** --- Optional endpoint name filter --- */
const FILTER_RE = ENDPOINT_FILTER ? new RegExp(ENDPOINT_FILTER, 'i') : null;

/** --- Build the flat list of endpoints to run --- */
const ENDPOINTS = [];
for (const feat of SELECTED_FEATURES) {
  const list = ENDPOINTS_BY_FEATURE[feat];
  if (!Array.isArray(list)) continue;
  for (const ep of list) {
    if (FILTER_RE && !String(ep.name || '').match(FILTER_RE)) continue;
    ENDPOINTS.push({ feature: feat, ...ep });
  }
}

/** Helpful log + guard */
console.log(
  `[k6] Selected ${ENDPOINTS.length} endpoint(s) across FEATURES=[${SELECTED_FEATURES.join(', ')}], ` +
  `FILTER=${ENDPOINT_FILTER || 'none'}`
);
if (ENDPOINTS.length === 0) {
  console.error('[k6] No endpoints selected. Available features:', ALL_FEATURES.join(', '));
}

/** --- k6 options --- */
export const options = ENDPOINTS.length
  ? {
      scenarios: {
        default: {
          executor: 'constant-arrival-rate',
          rate: RPS,
          timeUnit: '1s',
          duration: DURATION,
          preAllocatedVUs: PREALLOC,
          maxVUs: Math.max(PREALLOC, MAXVUS),
        },
      },
      thresholds: {
        // Example global threshold (adjust/disable as needed)
        'http_req_duration{expected_response:true}': ['p(95) < 60000'],
      },
    }
  : {
      scenarios: {}, // nothing runs, but we still emit a summary
    };

/** --- Per-request metrics (tagged) --- */
const reqs_ep = new Counter('reqs_ep');
const latency_ep = new Trend('latency_ep');
const checks_ep = new Counter('checks_ep');

/** --- Headers helper --- */
function buildHeaders(method) {
  const h = {
    'Accept': 'application/json',
  };
  if (TOKEN) h['Authorization'] = `Bearer ${TOKEN}`;
  // add any method-specific defaults if you like
  return h;
}

/** --- Optional BASE_URL host override --- */
function resolveUrl(sourceUrl) {
  if (!BASE_URL_OVERRIDE) return sourceUrl;
  try {
    const src = new URL(sourceUrl);
    const base = new URL(BASE_URL_OVERRIDE);
    // preserve path & query from source, only swap scheme+host+port
    base.pathname = src.pathname;
    base.search = src.search;
    return base.toString();
  } catch (_) {
    return sourceUrl;
  }
}

/** --- Simple round-robin iterator over the selected endpoints --- */
let idx = 0;

/** --- Main iteration --- */
export default function () {
  if (!ENDPOINTS.length) {
    // nothing selected -> no-op iteration
    sleep(0.2);
    return;
  }

  const ep = ENDPOINTS[idx++ % ENDPOINTS.length];
  const tags = { feature: ep.feature, endpoint: String(ep.name || 'unknown') };

  const url = resolveUrl(ep.url);
  const headers = buildHeaders(ep.method || 'GET');

  let res;

  try {
    switch (String(ep.method || 'GET').toUpperCase()) {
      case 'GET':
        res = http.get(url, { headers, tags });
        break;
      case 'POST':
        res = http.post(url, ep.body || null, { headers, tags });
        break;
      case 'PUT':
        res = http.put(url, ep.body || null, { headers, tags });
        break;
      case 'PATCH':
        res = http.patch(url, ep.body || null, { headers, tags });
        break;
      case 'DELETE':
        res = http.del(url, null, { headers, tags });
        break;
      default:
        // Fallback as GET
        res = http.get(url, { headers, tags });
        break;
    }
  } catch (e) {
    // Network/runtime errors still push a request count with latency ~ 0
    reqs_ep.add(1, tags);
    latency_ep.add(0, tags);
    checks_ep.add(0, tags);
    console.error(`[k6] Request error for ${tags.feature} / ${tags.endpoint}: ${e && e.message}`);
    sleep(0.2);
    return;
  }

  // Record per-request metrics
  reqs_ep.add(1, tags);
  latency_ep.add(res.timings.duration || 0, tags);

  // Basic checks (status + body presence). You can customize per-endpoint if your JSON supplies expectations.
  const expectStatus = Number(ep.expectStatus || 200);
  const expectBody = ep.expectBodyContains || null;

  const ok = check(
    res,
    {
      'status ok': (r) => r.status === expectStatus,
      ...(expectBody
        ? { 'body has text': (r) => String(r.body || '').indexOf(expectBody) !== -1 }
        : {}),
    },
    tags
  );

  checks_ep.add(ok ? 1 : 0, tags);

  // a tiny think time helps avoid “all at once” burstiness at low rates
  sleep(0.2);
}

/** --- HTML summary hook --- */
export function handleSummary(data) {
  return handleSummary(data);
}
