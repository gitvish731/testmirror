// probe
import http from "k6/http";
import { sleep } from "k6";
import features from "../sources/endpoints.byFeature.js"; // default ESM export

// -------- env ----------
var FEAT = (__ENV.FEATURES || "").toString().trim();
var VUS = Number(__ENV.VUS || "1");
var ITERS = Number((__ENV.ITERS || __ENV.ITER || "0").toString());
var DURATION = (__ENV.DURATION || "30s").toString();

var SELECTED = FEAT
  ? FEAT.split(",").map(function (s) { return s.trim(); }).filter(function (s) { return s.length; })
  : [];

console.log(
  "parsed -> vus=" + VUS +
  ", iters=" + ITERS +
  ", duration=" + DURATION +
  ", features=" + (SELECTED.length ? SELECTED.join("|") : "(all)")
);

// -------- executor --------
export var options = ITERS > 0 ? {
  scenarios: { by_iter: { executor: "per-vu-iterations", vus: VUS, iterations: ITERS, maxDuration: "10m" } }
} : {
  scenarios: { by_time: { executor: "constant-vus", vus: VUS, duration: DURATION, gracefulStop: "3s" } }
};
console.log("executor chosen -> " + (ITERS > 0 ? "per-vu-iterations" : "constant-vus"));

// -------- build endpoints (very defensive) --------
function isPO(x){ return x && typeof x === "object" && !Array.isArray(x); }

var ENDPOINTS = [];
if (!isPO(features)) {
  console.error("features export invalid; typeof =", typeof features);
} else {
  var available = Object.keys(features);
  console.log("features available:", JSON.stringify(available));
  var names = SELECTED.length ? SELECTED : available;

  for (var i = 0; i < names.length; i++) {
    var fname = names[i];
    var list = features[fname];
    if (!Array.isArray(list)) {
      console.warn("Feature not found or not an array:", fname);
      continue;
    }
    for (var j = 0; j < list.length; j++) {
      var ep = list[j];
      if (!isPO(ep)) continue;

      var method = (ep.method || "GET").toUpperCase();
      var url = String(ep.url || "");
      if (!url) { console.warn("Skipping endpoint with empty url in feature:", fname); continue; }

      ENDPOINTS.push({
        feature: fname,
        name: ep.name || (method + " " + url),
        method: method,
        url: url,
        headers: isPO(ep.headers) ? ep.headers : undefined,
        auth: ep.auth || null
      });
    }
  }
}

console.log("endpoints built:", ENDPOINTS.length);
if (ENDPOINTS.length) {
  console.log("first endpoint:", JSON.stringify(ENDPOINTS[0]));
}

export default function () {
  if (!ENDPOINTS.length) { sleep(0.25); return; }

  try {
    // Always hit the first endpoint to avoid any indexing issues
    var ep = ENDPOINTS[0];

    // Build params without tags/metrics
    var params = {};
    if (ep.headers) params.headers = ep.headers;
    if (ep.auth) {
      var h = params.headers || {};
      h.authorization = String(ep.auth);
      params.headers = h;
    }

    // Only GET for the probe (your feature is GET anyway)
    console.log("GET ->", ep.url);
    var res = http.get(ep.url, params);

    var status = res ? res.status : "(no response)";
    var blen = (res && typeof res.body === "string") ? res.body.length
              : (res && res.body ? JSON.stringify(res.body).length : 0);

    console.log("response status:", status, "body length:", blen);
  } catch (e) {
    console.error("probe iteration error:", String(e && e.message || e));
  }

  sleep(0.25);
}
