// perf/k6/scenarios/from-playwright.http.js
// k6 v0.46-compatible runner with iteration/duration switch and per-endpoint metrics

import http from "k6/http";
import { sleep, check, Trend, Counter } from "k6";
import features from "../sources/endpoints.byFeature.js"; // <- default export (ESM)

const VUS = Number(__ENV.VUS || 1);
const ITERS = Number(__ENV.ITERS || 0);
const DURATION = String(__ENV.DURATION || ""); // used only when ITERS==0
const FEATURES_RAW = String(__ENV.FEATURES || ""); // e.g. "ReportingAPI Alpha1,Another Feature"
const ENV = String(__ENV.ENV || __ENV.ENVIRONMENT || ""); // if you later need it

// -------- executor selection (rule: ITERS>0 => per-vu-iterations) --------
export const options = {
  scenarios: {
    default:
      ITERS > 0
        ? {
            executor: "per-vu-iterations",
            vus: VUS,
            iterations: ITERS,
            // generous cap so per-vu-iterations doesn't time out
            maxDuration: "1h",
          }
        : {
            executor: "constant-vus",
            vus: VUS,
            duration: DURATION || "30s",
          },
  },
};

// -------- build selected endpoint list from the features map --------
const ALL_FEATURE_NAMES = [];
for (const k in features) {
  if (Object.prototype.hasOwnProperty.call(features, k)) ALL_FEATURE_NAMES.push(k);
}

const SELECTED_FEATURES =
  FEATURES_RAW.trim().length > 0
    ? FEATURES_RAW.split(",").map((s) => s.trim()).filter((s) => s.length > 0)
    : ALL_FEATURE_NAMES.slice();

const ENDPOINTS = [];
for (let i = 0; i < SELECTED_FEATURES.length; i++) {
  const fname = SELECTED_FEATURES[i];
  const eps = features[fname];
  if (!eps || !Array.isArray(eps)) continue;
  for (let j = 0; j < eps.length; j++) {
    // keep only allowed fields the runner uses
    const { name, method, url, expect, headers, auth } = eps[j];
    ENDPOINTS.push({
      feature: fname,
      name: String(name || ("ep_" + j)),
      method: String(method || "GET").toUpperCase(),
      url: String(url || ""),
      expect: expect || { status: 200 },
      headers: headers || null,
      auth: auth || null,
    });
  }
}

if (ENDPOINTS.length === 0) {
  throw new Error(
    "No endpoints selected. FEATURES='" +
      FEATURES_RAW +
      "' did not match any of: " +
      ALL_FEATURE_NAMES.join(", ")
  );
}

// -------- per-endpoint custom metrics so they show in summary.json (k6 v0.46) --------
const EP_METRICS = {}; // key -> { t: Trend, c: Counter }
function metricKey(feature, endpoint) {
  const clean = (s) => String(s).replace(/[^A-Za-z0-9_]/g, "_").slice(0, 60);
  return "ep_" + clean(feature) + "__" + clean(endpoint);
}
function getEpMetrics(feature, endpoint) {
  const key = metricKey(feature, endpoint);
  if (!EP_METRICS[key]) {
    EP_METRICS[key] = {
      t: new Trend(key + "_latency_ms"),
      c: new Counter(key + "_reqs"),
    };
  }
  return EP_METRICS[key];
}

// -------- simple round-robin pick for each iteration --------
function pickEndpoint() {
  // __ITER and __VU are provided by k6
  const idx = (__ITER || 0) % ENDPOINTS.length;
  return ENDPOINTS[idx];
}

// -------- main iteration --------
export default function () {
  const ep = pickEndpoint();

  const reqParams = {
    tags: {
      feature: ep.feature,
      endpoint: ep.name,
    },
    headers: Object.assign({}, ep.headers || {}),
  };

  // very basic bearer token support if you ever pass one in your feature map
  if (ep.auth && ep.auth.type === "bearer" && ep.auth.token) {
    reqParams.headers.Authorization = "Bearer " + ep.auth.token;
  }

  let res;
  if (ep.method === "GET") {
    res = http.get(ep.url, reqParams);
  } else if (ep.method === "POST") {
    const body = ep.body || "";
    // default content-type if not specified
    if (!reqParams.headers["Content-Type"] && !reqParams.headers["content-type"]) {
      reqParams.headers["Content-Type"] = "application/json";
    }
    res = http.post(ep.url, body, reqParams);
  } else if (ep.method === "PATCH") {
    const body = ep.body || "";
    if (!reqParams.headers["Content-Type"] && !reqParams.headers["content-type"]) {
      reqParams.headers["Content-Type"] = "application/json";
    }
    res = http.patch(ep.url, body, reqParams);
  } else if (ep.method === "DELETE") {
    res = http.del(ep.url, null, reqParams);
  } else if (ep.method === "PUT") {
    const body = ep.body || "";
    if (!reqParams.headers["Content-Type"] && !reqParams.headers["content-type"]) {
      reqParams.headers["Content-Type"] = "application/json";
    }
    res = http.put(ep.url, body, reqParams);
  } else {
    throw new Error("Unsupported method: " + ep.method);
  }

  // record per-endpoint metrics (these appear in summary.json on v0.46)
  const m = getEpMetrics(ep.feature, ep.name);
  m.c.add(1);
  m.t.add(res && res.timings ? res.timings.duration : 0);

  // basic checks
  const expectedStatus = ep.expect && ep.expect.status ? ep.expect.status : 200;
  const expectedText = ep.expect && ep.expect.text ? String(ep.expect.text) : null;

  const ok = check(res, {
    "status ok": (r) => r && r.status === expectedStatus,
    "body has text": (r) =>
      expectedText ? String(r && r.body ? r.body : "").indexOf(expectedText) !== -1 : true,
  });

  // a short think time so per-vu-iterations runs look tidy
  sleep(0.2);
}
