import http from 'k6/http';
import { check, sleep } from 'k6';
import { SharedArray } from 'k6/data';

// Import feature/endpoint lists
import { ArtifactsRegistrationV1Alpha1 } from '../sources/endpoints.byFeature.js';

// Import reporter
export { handleSummary } from '../vendor/handleSummary.js';

// -------------
// Test options
// -------------
export const options = {
  scenarios: {
    by_iter: {
      executor: __ENV.DURATION
        ? 'constant-vus'
        : 'per-vu-iterations', // duration → run-time mode; else iterations-based
      vus: Number(__ENV.VUS || 1),
      duration: __ENV.DURATION || undefined, // e.g. "10s" or "1m"
      iterations: __ENV.ONE ? Number(__ENV.ONE) : undefined,
      gracefulStop: '3s',
    },
  },
  thresholds: {
    http_req_failed: ['rate<0.05'],
    http_req_duration: ['p(95)<2000'],
  },
};

// -------------
// Helpers
// -------------
function reqParams(featureName, endpointName, extra = {}) {
  return {
    headers: {
      ...(extra.headers || {}),
      'content-type': 'application/json',
      'authorization': extra.auth || '', // if you inject bearer later
    },
    tags: {
      feature: featureName,
      endpoint: endpointName,
      ...(extra.tags || {}),
    },
  };
}

const FEATURES = [
  { name: 'ReportingAPI Alpha1', endpoints: ArtifactsRegistrationV1Alpha1 },
];

// Shared array for reusability across VUs
const testMatrix = new SharedArray('feature-endpoints', () => FEATURES);

// -------------
// Main entrypoint
// -------------
export default function main() {
  for (const feat of testMatrix) {
    for (const ep of feat.endpoints) {
      const params = reqParams(feat.name, ep.name, { auth: ep.auth || '' });
      let res;

      // Pick method dynamically
      try {
        switch (ep.method.toUpperCase()) {
          case 'GET':
            res = http.get(ep.url, params);
            break;
          case 'POST':
            res = http.post(ep.url, ep.body || {}, params);
            break;
          case 'PATCH':
            res = http.patch(ep.url, ep.body || {}, params);
            break;
          case 'DELETE':
            res = http.del(ep.url, null, params);
            break;
          default:
            console.warn(`⚠ Unknown method ${ep.method} for ${ep.name}`);
            continue;
        }
      } catch (err) {
        console.error(`❌ Request failed for ${feat.name} → ${ep.name}:`, err);
        continue;
      }

      // Validate
      check(res, {
        'status ok': (r) => r.status === (ep.expect?.status || 200),
        'body has text': (r) => {
          const must = ep.expect?.text;
          return !must || String(r.body || '').includes(must);
        },
      });

      if (__ENV.DEBUG_TAGS === '1') {
        console.log(`Tags => ${JSON.stringify(params.tags)}`);
      }

      sleep(0.2); // pacing between requests
    }
  }
}
