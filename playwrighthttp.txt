// SDLC k6 | scenarios | from-playwright.http.js
// Emits per-feature/endpoint tags + custom metrics that handleSummary.js consumes.

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Counter, Trend } from 'k6/metrics';
export { handleSummary } from '../vendor/handleSummary.js';

// ---------- Custom metrics (tagged) ----------
var REQS_BY_EP = new Counter('reqs_by_ep');   // add(1, { feature, endpoint })
var LAT_BY_EP  = new Trend('latency_by_ep');  // add(ms, { feature, endpoint })

// ---------- Endpoints map generated by gen-k6-endpoints ----------
var ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));

// ---------- Env ----------
var ENV = __ENV || {};
var DURATION   = ENV.DURATION   || '30s';
var RPS        = Number(ENV.RPS || 1);
var PREALLOC   = Number(ENV.PREALLOC || 5);
var MAXVUS     = Number(ENV.MAXVUS || 35);
var BASE_URL   = (ENV.BASE_URL || '').trim();
var TOKEN      = (ENV.TOKEN || ENV.GRAFEAS_LOGIN_TOKEN || '').trim();

var FEATURES_RAW     = (ENV.FEATURES || '').trim();                 // CSV of feature names
var ENDPOINT_FILTER  = (ENV.ENDPOINT_FILTER || '').trim().toLowerCase(); // substring on endpoint name

// ---------- Select endpoints ----------
function selectEndpoints () {
  var allFeatures = Object.keys(ENDPOINTS_BY_FEATURE);
  var selectedFeatureNames = (FEATURES_RAW ? FEATURES_RAW.split(',') : allFeatures)
    .map(function (s) { return (s || '').trim(); })
    .filter(function (s) { return !!s; });

  var flat = [];

  for (var i = 0; i < selectedFeatureNames.length; i++) {
    var f = selectedFeatureNames[i];
    var eps = ENDPOINTS_BY_FEATURE[f];
    if (!eps || !eps.length) {
      console.warn('Feature "' + f + '" not found in endpoints.byFeature.json');
      continue;
    }
    for (var j = 0; j < eps.length; j++) {
      var ep = eps[j];

      if (ENDPOINT_FILTER && String(ep.name || '').toLowerCase().indexOf(ENDPOINT_FILTER) === -1) {
        continue;
      }

      // copy & annotate
      var epCopy = Object.assign({}, ep, { feature: f });

      // optional BASE_URL override: replace scheme/host
      if (BASE_URL) {
        try {
          var u = new URL(epCopy.url);
          var b = new URL(BASE_URL);
          u.protocol = b.protocol;
          u.host = b.host;
          epCopy.url = u.toString();
        } catch (e) {
          // keep original
        }
      }

      flat.push(epCopy);
    }
  }

  if (!flat.length) {
    console.warn('No endpoints selected. Check FEATURES="' + FEATURES_RAW + '" and ENDPOINT_FILTER="' + ENDPOINT_FILTER + '".');
  } else {
    console.info('Selected ' + flat.length + ' endpoint(s) across FEATURES=[' + selectedFeatureNames.join(', ') + ']');
  }

  return flat;
}

var ENDPOINTS = selectEndpoints();

// ---------- Headers ----------
function buildHeaders (method) {
  var m = String(method || '').toUpperCase();
  var headers = {};

  if (TOKEN) {
    headers['Authorization'] = 'Bearer ' + TOKEN;
  }
  if (m === 'POST' || m === 'PUT' || m === 'PATCH') {
    headers['Content-Type'] = 'application/json';
  }
  return headers;
}

// ---------- k6 options ----------
export var options = {
  scenarios: {
    default: {
      executor: 'constant-arrival-rate',
      rate: RPS,
      timeUnit: '1s',
      duration: DURATION,
      preAllocatedVUs: PREALLOC,
      maxVUs: MAXVUS
    }
  },
  thresholds: {
    http_req_failed: ['rate<0.20'],
    'http_req_duration{expected_response:true}': ['p(95)<60000'],
    // make sure these exist so the reporter can pick them up
    reqs_by_ep: ['count>=0'],
    latency_by_ep: ['p(95)>=0']
  }
};

// ---------- Main ----------
export default function () {
  for (var i = 0; i < ENDPOINTS.length; i++) {
    var ep = ENDPOINTS[i];
    var tags = {
      feature: ep.feature,
      endpoint: ep.name || ep.url
    };

    var params = { headers: buildHeaders(ep.method), tags: tags };
    var expectStatus = (ep && ep.expect && typeof ep.expect.status !== 'undefined') ? ep.expect.status : 200;
    var mustContain  = (ep && ep.expect && ep.expect.text) ? String(ep.expect.text) : null;

    var res;

    try {
      var method = String(ep.method || '').toUpperCase();
      if (method === 'GET') {
        res = http.get(ep.url, params);
      } else if (method === 'POST') {
        res = http.post(ep.url, ep.body || '', params);
      } else if (method === 'PUT') {
        res = http.put(ep.url, ep.body || '', params);
      } else if (method === 'PATCH') {
        res = http.patch(ep.url, ep.body || '', params);
      } else if (method === 'DELETE') {
        res = http.del(ep.url, null, params);
      } else {
        console.warn('Unsupported method "' + ep.method + '" for ' + tags.endpoint);
        continue;
      }

      // tagged custom metrics
      REQS_BY_EP.add(1, tags);
      LAT_BY_EP.add(res.timings.duration, tags);

      // checks
      var checks = {
        'status ok': function (r) { return r.status === expectStatus; }
      };
      if (mustContain) {
        checks['body has text'] = function (r) {
          return String(r.body || '').indexOf(mustContain) !== -1;
        };
      }
      check(res, checks, tags);
    } catch (e) {
      REQS_BY_EP.add(1, tags); // still count the attempt
      console.error('Request failed for [' + tags.feature + '] ' + tags.endpoint + ': ' + String(e));
    }

    sleep(0.1);
  }
}
