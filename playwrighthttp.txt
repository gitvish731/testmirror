/* perf/k6/scenarios/from-playwright.http.js
 * Runner that:
 *  - loads endpoints from ../sources/endpoints.byFeature.js (or JSON fallback)
 *  - tags every request with { feature, endpoint, ep_id }
 *  - pushes custom per-endpoint metrics: reqs_ep_<id> (Counter) and time_ep_<id> (Trend)
 *    so the HTML summaryâ€™s Feature/Endpoint table can populate.
 */

const http = require('k6/http');
const { check, sleep } = require('k6');
const { Counter, Trend } = require('k6/metrics');

/* ----------------------- env knobs (with sane defaults) ---------------------- */
const ENV = (typeof __ENV === 'object' && __ENV) || {};
const DEV = String(ENV.dev || '').toLowerCase() === 'true';

const DURATION  = ENV.DURATION  || '30s';
const RPS       = Number(ENV.RPS || 1);          // arrivals / sec
const PREALLOC  = Number(ENV.PREALLOC || 6);
const MAXVUS    = Number(ENV.MAXVUS || Math.max(PREALLOC, 6));
const FEATURES_RAW = (ENV.FEATURES || '').trim();
const ENDPOINT_FILTER = (ENV.ENDPOINT_FILTER || '').trim();

/* thresholds on/off */
const THRESHOLDS_ON = String(ENV.THRESHOLDS_ON || 'false').toLowerCase() === 'true';

/* ----------------------- load endpoints map (JS -> JSON) --------------------- */
function loadEndpointsByFeature() {
  // First try the JS wrapper (generated by your k6:gen script),
  // then fall back to the JSON file, both located in ../sources/
  try {
    let mod = require('../sources/endpoints.byFeature.js');
    // handle either module.exports = {...} or export default {...}
    if (mod && mod.default) mod = mod.default;
    return mod || {};
  } catch (_e) {
    try {
      const raw = open('../sources/endpoints.byFeature.json');
      return JSON.parse(raw);
    } catch (_e2) {
      console.error('Could not load endpoints.byFeature (JS or JSON).');
      return {};
    }
  }
}

const ENDPOINTS_BY_FEATURE = loadEndpointsByFeature();

/* ----------------------- feature/endpoint selection -------------------------- */
function normalize(s) { return String(s || '').toLowerCase(); }

const SELECTED_FEATURES =
  FEATURES_RAW
    ? FEATURES_RAW.split(',').map(s => s.trim()).filter(Boolean)
    : Object.keys(ENDPOINTS_BY_FEATURE);

const ENDPOINTS = [];
for (const feat of SELECTED_FEATURES) {
  // match case-insensitively against the available keys
  const featureKey = Object.keys(ENDPOINTS_BY_FEATURE).find(
    k => normalize(k) === normalize(feat)
  );
  if (!featureKey) continue;

  const list = ENDPOINTS_BY_FEATURE[featureKey] || [];
  for (const ep of list) {
    // attach display feature for tagging
    ep.feature = featureKey;
    if (ENDPOINT_FILTER && !String(ep.name || '').toLowerCase().includes(ENDPOINT_FILTER.toLowerCase())) {
      continue;
    }
    ENDPOINTS.push(ep);
  }
}

console.info(`Selected ${ENDPOINTS.length} endpoint(s) across FEATURES: [${SELECTED_FEATURES.join(', ')}]`);

/* ----------------------- custom per-endpoint metrics ------------------------- */
/* We create named k6 metrics *per endpoint id* on first use and cache them. */
const METRIC_CACHE = Object.create(null);

function safeId(s) {
  // keep id filesystem/metric-safe and deterministic
  return String(s || '')
    .toLowerCase()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_-]/g, '');
}

function endpointId(ep) {
  const f = safeId(ep.feature || '');
  const n = safeId(ep.name || '');
  return f ? `${f}__${n}` : n;
}

function perEndpointMetrics(id) {
  if (!METRIC_CACHE[id]) {
    // These names are what the HTML summary looks for (prefix scan):
    //   - reqs_ep_<id>  (Counter)
    //   - time_ep_<id>  (Trend)
    METRIC_CACHE[id] = {
      reqs: new Counter(`reqs_ep_${id}`),
      time: new Trend(`time_ep_${id}`),
    };
  }
  return METRIC_CACHE[id];
}

/* ----------------------- k6 options ----------------------------------------- */
const thresholds = THRESHOLDS_ON
  ? {
      http_req_failed: ['rate<0.01'],
      'http_req_duration{expected_response:true}': ['p(95)<60000'], // 60s P95
    }
  : {};

export const options = {
  scenarios: {
    ep: {
      executor: 'constant-arrival-rate',
      rate: RPS,
      timeUnit: '1s',
      duration: DURATION,
      preAllocatedVUs: PREALLOC,
      maxVUs: MAXVUS,
    },
  },
  thresholds,
  // tags at test level (request-level tags are still set per request below)
  tags: {
    test: 'sdlc-autogov-k6',
  },
  noConnectionReuse: false,
  discardResponseBodies: false,
};

/* ----------------------- request runner ------------------------------------- */
function buildHeaders(method, ep) {
  const headers = Object.assign({}, ep.headers || {});
  // bearer token if provided via ENV
  if (ENV.TOKEN && !headers.Authorization) {
    headers.Authorization = `Bearer ${ENV.TOKEN}`;
  }
  // typical JSON defaults for non-GET
  if (method !== 'GET') {
    if (!headers['Content-Type']) headers['Content-Type'] = 'application/json';
    if (!headers.Accept) headers.Accept = 'application/json';
  }
  return headers;
}

function runOne(ep) {
  const id = endpointId(ep);
  const tags = { feature: String(ep.feature || ''), endpoint: String(ep.name || ''), ep_id: id };

  const headers = buildHeaders(ep.method || 'GET', ep);

  let res;
  const opts = { headers, tags };

  try {
    const m = (ep.method || 'GET').toUpperCase();
    if (m === 'GET') {
      res = http.get(ep.url, opts);
    } else if (m === 'POST') {
      res = http.post(ep.url, ep.body ?? '', opts);
    } else if (m === 'PATCH') {
      res = http.patch(ep.url, ep.body ?? '', opts);
    } else if (m === 'DELETE') {
      res = http.del(ep.url, null, opts);
    } else {
      console.warn(`Unsupported method ${m} for ${ep.name || ep.url}`);
      return;
    }

    const expectStatus = (ep.expect && ep.expect.status) || 200;
    const mustContain  = (ep.expect && ep.expect.text) || null;

    check(res, {
      'status ok': (r) => r.status === expectStatus,
      'body has text': (r) => (mustContain ? String(r.body || '').indexOf(mustContain) !== -1 : true),
    }, tags);

    // push custom metrics (these are what the HTML summary aggregates)
    const M = perEndpointMetrics(id);
    M.reqs.add(1, tags);
    M.time.add(res.timings.duration, tags);

  } catch (e) {
    console.error(`Request error for ${ep.name || ep.url}: ${e} (id=${id})`);
  }
}

/* ----------------------- k6 default entry ----------------------------------- */
export default function () {
  // round-robin a single endpoint per VU iteration
  if (ENDPOINTS.length === 0) {
    sleep(1);
    return;
  }
  const i = Math.floor(Math.random() * ENDPOINTS.length);
  runOne(ENDPOINTS[i]);
  sleep(0.1); // tiny think time
}
