// perf/k6/scenarios/from-playwright.http.js
/* k6 runtime: CommonJS style (works without bundling) */

const http = require('k6/http');
const { sleep, check } = require('k6');

// ---- Config via env ----
const ENV = String(__ENV.ENV || 'uat').toLowerCase();           // dev | uat
const TOKEN = __ENV.TOKEN || __ENV.GRAFEAS_LOGIN_TOKEN || '';
const FEATURES_RAW = String(__ENV.FEATURES || '').trim();        // comma-separated or empty for all
const ENDPOINT_FILTER = String(__ENV.ENDPOINT_FILTER || '').trim();

const DURATION = String(__ENV.DURATION || '30s');
const RPS = Number(__ENV.RPS || 1);
const PREALLOC = Number(__ENV.PREALLOC || 5);
const MAXVUS = Number(__ENV.MAXVUS || 10);

// Optional thresholds (toggle with THRESHOLDS=true)
const THRESHOLDS_ON = /^true$/i.test(String(__ENV.THRESHOLDS || 'false'));
const THRESHOLDS = {
  http_req_failed: ['rate<0.05'],
  http_req_duration: ['p(95)<40000'], // 40s default until you tune
};

// ---- Load endpoints map (prefer JSON) ----
function loadEndpointsByFeature() {
  // k6's open() reads files at init time; path is relative to this file
  try {
    const txt = open('../sources/endpoints.byFeature.json');
    return JSON.parse(txt);
  } catch (e) {
    // Fallback: the TS may have been emitted as JS; last resort try JSON again from CWD
    return {};
  }
}

const ENDPOINTS_BY_FEATURE = loadEndpointsByFeature();

// ---- Host swap (-dev / -test) based on ENV ----
function swapEnvHost(url) {
  // Only flip the environment suffix immediately before the domain dot
  // e.g. *.sdlcapis-test.azpriv-cloud.ubs.net <-> *.sdlcapis-dev.azpriv-cloud.ubs.net
  const want = (ENV === 'dev') ? 'dev' : 'test'; // uat -> test
  return String(url).replace(/-(dev|test)\./, `-${want}.`);
}

// ---- Select features/endpoints ----
function selectedFeatures() {
  if (!FEATURES_RAW) {
    // Everything
    return Object.keys(ENDPOINTS_BY_FEATURE);
  }
  return FEATURES_RAW
    .split(',')
    .map(s => s.trim())
    .filter(Boolean)
    .map(n => n); // names are already without .spec in your generator
}

function collectEndpoints() {
  const out = [];
  const feats = selectedFeatures();
  for (var i = 0; i < feats.length; i++) {
    var f = feats[i];
    var list = ENDPOINTS_BY_FEATURE[f] || [];
    for (var j = 0; j < list.length; j++) {
      var ep = list[j];
      if (ENDPOINT_FILTER && String(ep.name).toLowerCase().indexOf(ENDPOINT_FILTER.toLowerCase()) === -1) {
        continue;
      }
      // clone + host swap
      var url = swapEnvHost(ep.url || ep.path || '');
      out.push({
        feature: f,
        name: ep.name,
        method: ep.method || 'GET',
        url: url,
        body: (ep.body || ''),
        expect: ep.expect || { status: 200 },
      });
    }
  }
  return out;
}

const ENDPOINTS = collectEndpoints();

// ---- Single endpoint runner (by index) with tags ----
function runOne(i) {
  var ep = ENDPOINTS[i];
  var tags = { feature: ep.feature, endpoint: ep.name };

  // Build request options
  var opts;
  if (ep.method === 'GET') {
    // GET: no Authorization header; only tags
    opts = { tags: tags };
  } else {
    // Non-GET: add Authorization + JSON content type
    var headers = { 'Content-Type': 'application/json' };
    if (TOKEN) headers.Authorization = `Bearer ${TOKEN}`;
    opts = { headers: headers, tags: tags };
  }

  var res;
  if (ep.method === 'GET') {
    res = http.get(ep.url, opts);
  } else if (ep.method === 'POST') {
    res = http.post(ep.url, ep.body || '', opts);
  } else if (ep.method === 'PUT') {
    res = http.put(ep.url, ep.body || '', opts);
  } else if (ep.method === 'PATCH') {
    res = http.patch(ep.url, ep.body || '', opts);
  } else if (ep.method === 'DELETE') {
    res = http.del(ep.url, null, opts);
  } else {
    // Unknown verb -> treat like GET
    res = http.get(ep.url, opts);
  }

  var want = (ep.expect && ep.expect.status) ? ep.expect.status : 200;
  check(res, { 'status ok': function (r) { return r.status === want; } }, tags);

  if (ep.expect && ep.expect.text) {
    var needle = String(ep.expect.text);
    check(res, { 'body has text': function (r) { return String(r.body || '').indexOf(needle) !== -1; } }, tags);
  }

  sleep(1);
}

// ---- Scenarios per endpoint and exports ----
var scenarios = {};
for (var i = 0; i < ENDPOINTS.length; i++) {
  var ep = ENDPOINTS[i];
  scenarios['ep_' + i] = {
    executor: 'constant-arrival-rate',
    rate: RPS,
    timeUnit: '1s',
    duration: DURATION,
    preAllocatedVUs: PREALLOC,
    maxVUs: MAXVUS,
    exec: 'ep_' + i,
    tags: { feature: ep.feature, endpoint: ep.name },
  };
}

// Summary renderer
var handleSummaryImpl;
try {
  handleSummaryImpl = require('../vendor/handleSummary.js');
} catch (_e) {
  handleSummaryImpl = function (data) { return { stdout: JSON.stringify(data, null, 2) }; };
}

// Collect everything we export so k6 can see exec funcs
var exported = {
  options: { scenarios: scenarios, thresholds: THRESHOLDS_ON ? THRESHOLDS : {} },
  handleSummary: handleSummaryImpl,
};

for (var i = 0; i < ENDPOINTS.length; i++) {
  // create ep_0, ep_1, ...
  (function (idx) {
    exported['ep_' + idx] = function () { runOne(idx); };
  })(i);
}

module.exports = exported;
