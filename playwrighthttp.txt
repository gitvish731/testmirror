// perf/k6/scenarios/from-playwright.http.js

import http from 'k6/http';
import { check } from 'k6';
import { handleSummary as _handleSummary } from '../vendor/handleSummary.js';

// ---- config via env ----
const ENV         = (__ENV.ENV || 'dev').toLowerCase();           // 'dev' | 'uat'
const FEATURES    = (__ENV.FEATURES || '').split(',').map(s => s.trim()).filter(Boolean); // e.g. "ReportingAPI Alpha1"
const ENDPOINT_FILTER = (__ENV.ENDPOINT_FILTER || '').toLowerCase();
const RPS         = Number(__ENV.RPS || '1');
const DURATION    = __ENV.DURATION || '30s';
const PREALLOC    = Number(__ENV.PREALLOC || '6');
const MAXVUS      = Number(__ENV.MAXVUS || '40');
const TOKEN       = __ENV.TOKEN || ''; // Bearer for POST/PATCH/DELETE only

// read endpoints map generated by the generator
const ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));

// collect per-request meta for the HTML report
if (!globalThis.__k6_meta) globalThis.__k6_meta = [];

// swap -test <-> -dev in hostname based on ENV
function rewriteHost(urlStr) {
  let u;
  try { u = new URL(urlStr); } catch (_) { return urlStr; }
  if (ENV === 'dev')  u.hostname = u.hostname.replace(/-test\b/i, '-dev');
  if (ENV === 'uat')  u.hostname = u.hostname.replace(/-dev\b/i, '-test');
  return u.toString();
}

// choose features/endpoints
function selectedEndpoints() {
  const features = FEATURES.length ? FEATURES : Object.keys(ENDPOINTS_BY_FEATURE);
  const out = [];
  for (const feat of features) {
    const eps = ENDPOINTS_BY_FEATURE[feat] || [];
    for (const ep of eps) {
      if (ENDPOINT_FILTER && !String(ep.name || '').toLowerCase().includes(ENDPOINT_FILTER)) continue;
      out.push({ feature: feat, ...ep });
    }
  }
  return out;
}

const ENDPOINTS = selectedEndpoints();

// ---- k6 options: one scenario per endpoint ----
export const options = {
  scenarios: Object.fromEntries(
    ENDPOINTS.map((ep, i) => [
      `ep_${i}`,
      {
        executor: 'constant-arrival-rate',
        rate: RPS,
        timeUnit: '1s',
        duration: DURATION,
        preAllocatedVUs: PREALLOC,
        maxVUs: MAXVUS,
        exec: `ep_${i}`,
        tags: { feature: ep.feature, endpoint: ep.name, method: ep.method },
      },
    ])
  ),
  thresholds: {
    http_req_failed: ['rate<0.05'], // <5% errors
  },
};

// helpers to build headers per method
function buildHeaders(method) {
  const h = {};
  if (method !== 'GET') {
    if (TOKEN) h['Authorization'] = `Bearer ${TOKEN}`;
    h['Content-Type'] = 'application/json';
  }
  return h;
}

// generate one exported exec per endpoint
for (let i = 0; i < ENDPOINTS.length; i++) {
  const ep = ENDPOINTS[i];
  const fnName = `ep_${i}`;

  // eslint-disable-next-line no-eval
  eval(`
    export function ${fnName} () {
      const feature = ${JSON.stringify(ep.feature)};
      const epName  = ${JSON.stringify(ep.name)};
      const method  = ${JSON.stringify(ep.method)};
      const expect  = ${JSON.stringify(ep.expect || {})};
      const body    = ${JSON.stringify((ep.body || '').trim())};
      const tags    = { feature, endpoint: epName, method };
      const url     = rewriteHost(${JSON.stringify(ep.url)});

      const headers = buildHeaders(method);
      let res;

      if (method === 'GET') {
        res = http.get(url, { tags });
      } else if (method === 'POST') {
        res = http.post(url, body || null, { headers, tags });
      } else if (method === 'PATCH') {
        res = http.patch(url, body || null, { headers, tags });
      } else if (method === 'DELETE') {
        res = http.del(url, null, { headers, tags });
      } else {
        throw new Error('Unsupported method: ' + method);
      }

      const expectStatus = (expect && expect.status) ? expect.status : 200;
      check(res, { 'status ok': r => r.status === expectStatus }, tags);
      if (expect && expect.text) {
        check(res, { 'body has text': r => String(r.body || '').includes(expect.text) }, tags);
      }

      // feed reporter meta
      __k6_meta.push({
        feature, endpoint: epName, method,
        status: res.status,
        dur: res.timings.duration,
        ttfb: res.timings.waiting
      });
    }
  `);
}

// summary exporter (HTML + JSON)
export function handleSummary(data) {
  return _handleSummary(data);
}
