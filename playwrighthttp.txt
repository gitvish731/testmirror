import http from 'k6/http';
import { check, sleep } from 'k6';
import { Counter } from 'k6/metrics';

// -- Config via env -----------------------------------------------------------
const ENV        = (__ENV.ENV || 'dev').toLowerCase();  // 'dev' or 'uat'
const BASE_URL   = __ENV.BASE_URL || '';                // optional hard override
const TOKEN      = __ENV.TOKEN || '';                   // bearer for POST/PATCH/DELETE
const FEATURES   = (__ENV.FEATURES || '').split(',').map(s => s.trim()).filter(Boolean);
const ENDPOINT_FILTER = __ENV.ENDPOINT_FILTER ? new RegExp(__ENV.ENDPOINT_FILTER) : null;

// global/default per-endpoint rates (requests/second per endpoint)
const RPS      = Number(__ENV.RPS || '1');
const DURATION = __ENV.DURATION || '30s';
const PREALLOC = Number(__ENV.PREALLOC || '1');
const MAXVUS   = Number(__ENV.MAXVUS || '50');

// optional per-endpoint rate map: JSON like {"ReportingAPI Alpha1:GetReleaseStatus":5}
let EP_RATES = {};
try { if (__ENV.EP_RATES) EP_RATES = JSON.parse(__ENV.EP_RATES); } catch (_) {}

// -- Load endpoints (JSON generated by your script) ---------------------------
/* k6 'open()' reads a local file at load time (string); we parse it. */
const RAW = open('../sources/endpoints.byFeature.json');  // relative to this file
const BY_FEATURE = JSON.parse(RAW); // { "Feature Name": [ {name, method, url, ...}, ... ] }

// -- Helper: adjust host for dev/uat unless BASE_URL is explicitly provided --
function mapHost(u) {
  if (BASE_URL) {
    // If caller provided full base, replace {protocol}//{host} with BASE_URL
    try {
      const url = new URL(u);
      return BASE_URL.replace(/\/$/, '') + url.pathname + (url.search || '');
    } catch { return u; }
  }
  if (ENV === 'dev' || ENV === 'uat') {
    try {
      const url = new URL(u);
      // Replace first "-test" with "-dev" for dev, and ensure "-test" for uat
      const host = url.host.replace(/-dev(?=\.)/i, '-test'); // normalize
      const desired = ENV === 'dev' ? host.replace(/-test(?=\.)/i, '-dev') : host.replace(/-dev(?=\.)/i, '-test');
      url.host = desired;
      return url.toString();
    } catch { return u; }
  }
  return u;
}

// -- Build the list of selected endpoints ------------------------------------
const selected = [];
for (const [feature, list] of Object.entries(BY_FEATURE)) {
  if (FEATURES.length && !FEATURES.includes(feature)) continue;
  for (const ep of list) {
    if (ENDPOINT_FILTER && !ENDPOINT_FILTER.test(ep.name)) continue;
    selected.push({ feature, ...ep, url: mapHost(ep.url) });
  }
}
if (!selected.length) {
  console.error('No endpoints selected. Set FEATURES="Feature A,Feature B" or unset to include all.');
}

// -- k6 options: one constant-arrival-rate executor per endpoint -------------
export const options = {
  scenarios: selected.reduce((acc, ep) => {
    const key = `${ep.feature}:${ep.name}`;
    const rps = EP_RATES[key] ?? RPS;
    acc[key] = {
      executor: 'constant-arrival-rate',
      rate: rps,
      duration: DURATION,
      preAllocatedVUs: PREALLOC,
      maxVUs: MAXVUS,
      exec: 'hit'
    };
    return acc;
  }, {}),
  thresholds: {
    http_req_failed: ['rate<0.01']
  }
};

// -- A little metric for missing auth ----------------------------------------
const missingAuth = new Counter('missing_auth');

// -- Shared exec function -----------------------------------------------------
export function hit(data) {
  // k6 supplies the scenario name via __ENV-like params, but we know it from options key.
  // We'll look up the ep by the current scenario name:
  const scen = __ENV.__SCENARIO_NAME; // k6 injects this
  // If __SCENARIO_NAME is unavailable in your k6 version, derive via selected.find()
  const ep = selected.find(e => `${e.feature}:${e.name}` === scen) || selected[0];

  const headers = ep.headers || {};
  // Bearer only for non-GET
  const needsAuth = /^(POST|PATCH|DELETE)$/i.test(ep.method);
  const finalHeaders = Object.assign(
    {},
    headers,
    (needsAuth && TOKEN) ? { Authorization: `Bearer ${TOKEN}` } : {}
  );
  if (needsAuth && !TOKEN) missingAuth.add(1);

  let res;
  try {
    if (ep.method === 'GET')    res = http.get(ep.url, { headers: finalHeaders });
    else if (ep.method === 'POST')  res = http.post(ep.url, ep.body ?? null, { headers: finalHeaders });
    else if (ep.method === 'PUT')   res = http.put(ep.url, ep.body ?? null, { headers: finalHeaders });
    else if (ep.method === 'PATCH') res = http.patch(ep.url, ep.body ?? null, { headers: finalHeaders });
    else if (ep.method === 'DELETE')res = http.del(ep.url, null, { headers: finalHeaders });
    else                            res = http.request(ep.method, ep.url, ep.body ?? null, { headers: finalHeaders });
  } catch (e) {
    check(null, { 'request sent': () => false });
    return;
  }

  const want = ep.expect || {};
  const ok = check(res, {
    'status ok': () => want.status ? res.status === want.status : res.status >= 200 && res.status < 400,
    'text matches': () => {
      if (!want.text) return true;
      const txt = res.body ? String(res.body) : '';
      return txt.includes(want.text);
    }
  });

  if (!ok) {
    // small sleep to avoid immediate rehammer on bad endpoints
    sleep(0.1);
  }
}
