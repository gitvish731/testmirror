// perf/k6/scenarios/from-playwright.http.js

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Trend, Counter } from 'k6/metrics';

// ---- load endpoints map (generated by your gen script) ----
/**
 * Expected shape:
 * {
 *   "ReportingAPI Alpha1": [
 *     { name: "lists SBC ...", method: "GET", url: "https://...", expect: { status: 200, text: "releaseTagStatus" } }
 *   ],
 *   ...
 * }
 */
import ENDPOINTS_BY_FEATURE_RAW from '../sources/endpoints.byFeature.js';

// ---- import your HTML summary renderer (already in vendor) ----
import summaryRenderer from '../vendor/handleSummary.js';
export function handleSummary(data) { return summaryRenderer(data); }

// ---- custom metrics with tags (used by the renderer) ----
const reqs_ep = new Counter('reqs_ep');
const latency_ep = new Trend('latency_ep');

// ---- tiny helpers ----
function toInt(v, d) {
  const n = parseInt(v, 10);
  return isNaN(n) ? d : n;
}
function norm(s) { return String(s || '').trim(); }
function has(s) { return norm(s).length > 0; }

// ENV controls
const ONE = __ENV.ONE === '1';                 // oneshot: 1 VU, 1 iter
const VUS = toInt(__ENV.VUS, 0);               // e.g. 2
const ITER = toInt(__ENV.ITER, 0);             // e.g. 10 (per VU)
const DURATION = norm(__ENV.DURATION);         // e.g. "10s"
const FEATURES_RAW = norm(__ENV.FEATURES);     // e.g. "ReportingAPI Alpha1, Other"
const ENDPOINT_FILTER = norm(__ENV.ENDPOINT_FILTER); // optional substring filter
const ENV_NAME = norm(__ENV.ENV).toLowerCase();// "uat" | "dev" | "" (optional)

// ---- select features/endpoints ----
function loadEndpoints() {
  // tolerate JSON or JS export
  const MAP = ENDPOINTS_BY_FEATURE_RAW || {};
  const selected = [];

  // which features?
  const list = has(FEATURES_RAW)
    ? FEATURES_RAW.split(/[,\n]/).map(s => s.trim()).filter(Boolean)
    : Object.keys(MAP);

  for (let i = 0; i < list.length; i++) {
    const feature = list[i];
    const arr = MAP[feature] || [];
    if (arr && arr.length) {
      for (let j = 0; j < arr.length; j++) {
        const ep = arr[j];
        if (!has(ENDPOINT_FILTER) || String(ep.name || '').toLowerCase().indexOf(ENDPOINT_FILTER.toLowerCase()) !== -1) {
          selected.push({ feature: feature, ep: ep });
        }
      }
    }
  }

  if (!selected.length) {
    throw new Error('No endpoints found for FEATURES="' + list.join(', ') + '" (or they were filtered out).');
  }
  console.log('INFO Selected ' + selected.length + ' endpoint(s) across FEATURES: ' + list.join(' | '));
  return selected;
}

// Optional ENV-specific host tweak: replace "-test." with "-dev." when ENV=dev.
// Leave URLs as-is for anything else.
function applyEnvToUrl(url) {
  if (ENV_NAME === 'dev') {
    return String(url || '').replace('-test.', '-dev.');
  }
  return url;
}

// Build default headers; allow overriding via HEADERS_JSON env if you want.
function buildHeaders(method) {
  let base = {
    accept: 'application/json',
    'content-type': 'application/json',
    'user-agent': 'k6:auto-runner'
  };
  if (has(__ENV.HEADERS_JSON)) {
    try {
      const extra = JSON.parse(__ENV.HEADERS_JSON);
      // shallow assign
      for (const k in extra) { base[k] = extra[k]; }
    } catch (e) {
      console.error('WARN HEADERS_JSON is not valid JSON:', e && e.message);
    }
  }
  return base;
}

// ---- scenarios/options builder (flexible) ----
const REGULAR_FALLBACK = {
  scenarios: {
    default: {
      executor: 'constant-vus',
      vus: 1,
      duration: '30s',
      gracefulStop: '30s'
    }
  }
};

// precedence: ONE → ITER → DURATION → fallback
export const options = ONE
  ? {
      scenarios: {
        oneshot: {
          executor: 'per-vu-iterations',
          vus: 1,
          iterations: 1,
          maxDuration: '5m'
        }
      }
    }
  : (ITER > 0
      ? {
          scenarios: {
            iter: {
              executor: 'per-vu-iterations',
              vus: VUS > 0 ? VUS : 1,
              iterations: ITER,
              maxDuration: has(__ENV.MAXDUR) ? __ENV.MAXDUR : '30m'
            }
          }
        }
      : (has(DURATION)
          ? {
              scenarios: {
                run: {
                  executor: 'constant-vus',
                  vus: VUS > 0 ? VUS : 1,
                  duration: DURATION,
                  gracefulStop: '30s'
                }
              }
            }
          : REGULAR_FALLBACK));

// ---- main test ----
const SELECTED = loadEndpoints();

export default function () {
  // One “iteration” = exercising all selected endpoints once (your e2e unit).
  for (let i = 0; i < SELECTED.length; i++) {
    const feature = SELECTED[i].feature;
    const ep = SELECTED[i].ep;

    const method = String(ep.method || 'GET').toUpperCase();
    const url = applyEnvToUrl(ep.url || ep.uri || ep.href || '');
    const expected = ep.expect && typeof ep.expect.status !== 'undefined'
      ? Number(ep.expect.status)
      : 200;
    const mustContain = ep.expect && has(ep.expect.text) ? String(ep.expect.text) : null;

    const tags = { feature: feature, endpoint: String(ep.name || method + ' ' + url) };
    const headers = buildHeaders(method);

    let res;
    if (method === 'GET') {
      res = http.get(url, { headers: headers, tags: tags });
    } else if (method === 'POST') {
      const body = (ep.body && typeof ep.body === 'object') ? JSON.stringify(ep.body) : (ep.body || '');
      res = http.post(url, body, { headers: headers, tags: tags });
    } else if (method === 'PUT' || method === 'PATCH' || method === 'DELETE') {
      const body2 = (ep.body && typeof ep.body === 'object') ? JSON.stringify(ep.body) : (ep.body || '');
      res = http.request(method, url, body2, { headers: headers, tags: tags });
    } else {
      // fallback
      res = http.request(method, url, null, { headers: headers, tags: tags });
    }

    // push custom metrics (tagged)
    reqs_ep.add(1, tags);
    latency_ep.add(res.timings.duration, tags);

    // checks (tagged)
    check(res, {
      'status ok': r => r.status === expected,
      'body has text': r => (mustContain ? String(r.body || '').indexOf(mustContain) !== -1 : true)
    }, tags);

    // keep requests light; make this small if you want near back-to-back
    if (!ONE) { sleep(0.2); }
  }
}
