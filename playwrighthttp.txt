// SDLC k6 | scenarios | from-playwright.http.js
// ES5-safe (no optional chaining/spread). Emits tags + per-endpoint metrics for the HTML report.

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Counter, Trend } from 'k6/metrics';
export { handleSummary } from '../vendor/handleSummary.js';

// -------------------- Load endpoints generated by your script --------------------
var ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));

// -------------------- Env & defaults --------------------
var ENV = __ENV || {};
var DURATION  = ENV.DURATION || '30s';
var RPS       = Number(ENV.RPS || 1);
var PREALLOC  = Number(ENV.PREALLOC || 6);
var MAXVUS    = Number(ENV.MAXVUS || 35);
var BASE_URL  = (ENV.BASE_URL || '').trim();
var TOKEN     = (ENV.TOKEN || ENV.GRAFEAS_LOGIN_TOKEN || '').trim();

var FEATURES_RAW    = (ENV.FEATURES || '').trim();                 // CSV of feature names
var ENDPOINT_FILTER = (ENV.ENDPOINT_FILTER || '').trim().toLowerCase(); // substring on endpoint name

// -------------------- Utilities --------------------
function safeName(s) {
  // collapse to [a-z0-9_], keep it short to avoid metric-name limits
  var x = String(s || '').toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '');
  return x.substring(0, 80);
}

function buildHeaders(method) {
  var m = String(method || '').toUpperCase();
  var h = {};
  if (TOKEN) h['Authorization'] = 'Bearer ' + TOKEN;
  if (m === 'POST' || m === 'PUT' || m === 'PATCH') h['Content-Type'] = 'application/json';
  return h;
}

function selectEndpoints() {
  var allFeatures = Object.keys(ENDPOINTS_BY_FEATURE);
  var selected = (FEATURES_RAW ? FEATURES_RAW.split(',') : allFeatures)
    .map(function (s) { return (s || '').trim(); })
    .filter(function (s) { return !!s; });

  var flat = [];
  for (var i = 0; i < selected.length; i++) {
    var f = selected[i];
    var list = ENDPOINTS_BY_FEATURE[f];
    if (!list || !list.length) { console.warn('Feature "' + f + '" not found.'); continue; }

    for (var j = 0; j < list.length; j++) {
      var ep = list[j];

      if (ENDPOINT_FILTER && String(ep.name || '').toLowerCase().indexOf(ENDPOINT_FILTER) === -1) continue;

      // copy & annotate
      var copy = Object.assign({}, ep, { feature: f });

      // optional base-url override (replace scheme + host)
      if (BASE_URL) {
        try {
          var u = new URL(copy.url);
          var b = new URL(BASE_URL);
          u.protocol = b.protocol; u.host = b.host;
          copy.url = u.toString();
        } catch (e) { /* keep original */ }
      }

      flat.push(copy);
    }
  }

  if (flat.length) {
    console.info('Selected ' + flat.length + ' endpoint(s) across FEATURES=[' + selected.join(', ') + ']');
  } else {
    console.warn('No endpoints selected. Check FEATURES and ENDPOINT_FILTER.');
  }
  return flat;
}

var ENDPOINTS = selectEndpoints();

// -------------------- Per-endpoint metrics registry (for stable HTML reporting) --------------------
var EP_METRICS = {}; // key -> { reqs, latency }
function keyFor(ep) {
  return safeName(ep.feature + '__' + (ep.name || ep.url));
}
for (var i = 0; i < ENDPOINTS.length; i++) {
  var ep = ENDPOINTS[i];
  var key = keyFor(ep);
  if (!EP_METRICS[key]) {
    // Create unique metrics per endpoint (safe names)
    EP_METRICS[key] = {
      reqs:   new Counter('reqs_ep__' + key),   // Counter per endpoint
      lat:    new Trend('lat_ep__' + key)       // Trend per endpoint
    };
  }
}

// Also keep generic, taggable metrics (in case your reporter uses them)
var REQS_BY_EP = new Counter('reqs_by_ep');     // add(1, { feature, endpoint })
var LAT_BY_EP  = new Trend('latency_by_ep');    // add(ms, { feature, endpoint })

// -------------------- k6 options --------------------
export var options = {
  scenarios: {
    default: {
      executor: 'constant-arrival-rate',
      rate: RPS,
      timeUnit: '1s',
      duration: DURATION,
      preAllocatedVUs: PREALLOC,
      maxVUs: MAXVUS
    }
  },
  thresholds: {
    http_req_failed: ['rate<0.20'],
    'http_req_duration{expected_response:true}': ['p(95)<60000'],

    // force these to exist in the summary so handleSummary can find them
    reqs_by_ep: ['count>=0'],
    latency_by_ep: ['p(95)>=0']
  }
};

// -------------------- Main --------------------
export default function () {
  for (var i = 0; i < ENDPOINTS.length; i++) {
    var ep = ENDPOINTS[i];

    var tags = {
      feature: ep.feature,
      endpoint: ep.name || ep.url
    };

    var params = { headers: buildHeaders(ep.method), tags: tags };
    var expectStatus = (ep && ep.expect && typeof ep.expect.status !== 'undefined') ? ep.expect.status : 200;
    var mustContain  = (ep && ep.expect && ep.expect.text) ? String(ep.expect.text) : null;

    var res;
    var method = String(ep.method || '').toUpperCase();

    try {
      if (method === 'GET')        res = http.get(ep.url, params);
      else if (method === 'POST')  res = http.post(ep.url, ep.body || '', params);
      else if (method === 'PUT')   res = http.put(ep.url, ep.body || '', params);
      else if (method === 'PATCH') res = http.patch(ep.url, ep.body || '', params);
      else if (method === 'DELETE')res = http.del(ep.url, null, params);
      else { console.warn('Unsupported method "' + ep.method + '" for ' + tags.endpoint); continue; }

      // Per-endpoint metrics (stable metric names)
      var k = keyFor(ep);
      EP_METRICS[k].reqs.add(1);
      EP_METRICS[k].lat.add(res.timings.duration);

      // Generic, taggable metrics (in case reporter uses tags)
      REQS_BY_EP.add(1, tags);
      LAT_BY_EP.add(res.timings.duration, tags);

      // Checks
      var checks = { 'status ok': function (r) { return r.status === expectStatus; } };
      if (mustContain) {
        checks['body has text'] = function (r) { return String(r.body || '').indexOf(mustContain) !== -1; };
      }
      check(res, checks, tags);
    } catch (e) {
      // still count attempt
      var k2 = keyFor(ep);
      if (EP_METRICS[k2]) EP_METRICS[k2].reqs.add(1);
      REQS_BY_EP.add(1, tags);
      console.error('Request failed for [' + tags.feature + '] ' + tags.endpoint + ': ' + String(e && e.message ? e.message : e));
    }

    sleep(0.1);
  }
}
