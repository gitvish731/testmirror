// perf/k6/scenarios/from-playwright.http.js
import http from "k6/http";
import { sleep, check } from "k6";
import features from "../sources/endpoints.byFeature.js";

// ---- ENV / CLI -------------------------------------------------------------
// -e FEATURES='ReportingAPI Alpha1'  (comma separated allowed)
// -e VUS=1 -e ITERS=1                (use per-vu-iterations)
// OR
// -e VUS=2 -e DURATION=10s           (use constant-vus)
const RAW_FEATURES = String(__ENV.FEATURES || "").trim();
const SELECTED_FEATURE_NAMES = RAW_FEATURES
  ? RAW_FEATURES.split(",").map((s) => s.trim()).filter(Boolean)
  : []; // empty => all

const VUS = Number(__ENV.VUS || "1");
const ITERS = Number(__ENV.ITERS || "0");      // per-VU iterations when > 0
const DURATION = String(__ENV.DURATION || "30s");

// ---- Choose scenario (v0.46 compatible) ------------------------------------
export const options = ITERS > 0
  ? {
      scenarios: {
        by_iter: {
          executor: "per-vu-iterations",
          vus: VUS,
          iterations: ITERS,         // iterations PER VU
          maxDuration: "10m",
        },
      },
    }
  : {
      scenarios: {
        by_time: {
          executor: "constant-vus",
          vus: VUS,
          duration: DURATION,
          gracefulStop: "3s",
        },
      },
    };

console.log(
  `k6 config -> executor=${ITERS > 0 ? "per-vu-iterations" : "constant-vus"}, ` +
  `vus=${VUS}, iters=${ITERS}, duration=${DURATION}`
);

// ---- Build the flat endpoint list ------------------------------------------
function isPlainObject(x) {
  return x && typeof x === "object" && !Array.isArray(x);
}

const ALL_FEATURE_NAMES = Object.keys(isPlainObject(features) ? features : {});
if (ALL_FEATURE_NAMES.length === 0) {
  console.error("No features loaded from ../sources/endpoints.byFeature.js");
}

const EFFECTIVE_FEATURES = SELECTED_FEATURE_NAMES.length
  ? SELECTED_FEATURE_NAMES
  : ALL_FEATURE_NAMES;

console.log(`features_loaded: ${JSON.stringify(EFFECTIVE_FEATURES)}`);

const ENDPOINTS = [];
for (const fname of EFFECTIVE_FEATURES) {
  const list = features[fname];
  if (!Array.isArray(list)) {
    console.warn(`Feature "${fname}" has no endpoint array; skipping.`);
    continue;
  }
  for (const ep of list) {
    if (!isPlainObject(ep)) {
      console.warn(`Feature "${fname}" contains a non-object endpoint; skipping.`);
      continue;
    }
    const url = ep.url && String(ep.url);
    const method = ep.method && String(ep.method || "GET").toUpperCase();
    if (!url || !method) {
      console.warn(`Feature "${fname}" endpoint missing url/method; skipping.`);
      continue;
    }
    // Minimal, safe shape
    const expect = isPlainObject(ep.expect) ? ep.expect : {};
    const status = Number(expect.status || 200);
    const text = typeof expect.text === "string" ? expect.text : "";

    // headers: only accept plain object
    const headers = isPlainObject(ep.headers) ? ep.headers : undefined;

    // Build a safe, normalized record
    ENDPOINTS.push({
      feature: fname,
      name: String(ep.name || `${method} ${url}`),
      method,
      url,
      expect: { status, text },
      headers,
    });
  }
}

if (ENDPOINTS.length === 0) {
  console.error("No valid endpoints to run after normalization.");
}

// ---- Main iteration ---------------------------------------------------------
export default function () {
  if (ENDPOINTS.length === 0) {
    // Nothing to do; avoid throwing TypeErrors
    sleep(0.2);
    return;
  }

  // Round-robin selection so each VU walks the same list
  const idx = (__ITER || 0) % ENDPOINTS.length;
  const ep = ENDPOINTS[idx];

  const params = {};
  if (ep.headers) params.headers = ep.headers;

  let res;
  switch (ep.method) {
    case "GET":
      res = http.get(ep.url, params);
      break;
    default:
      // Only GET is enabled for now to keep things simple
      console.warn(`Method ${ep.method} not implemented in runner (GET only).`);
      res = http.get(ep.url, params);
      break;
  }

  // Checks
  const ok = check(res, {
    "status ok": (r) => r && r.status === ep.expect.status,
    "body has text": (r) => {
      if (!ep.expect.text) return true; // nothing to assert
      const body = r && r.body;
      if (body == null) return false;
      const s = typeof body === "string" ? body : JSON.stringify(body);
      return s.indexOf(ep.expect.text) !== -1;
    },
  });

  // tiny think time
  sleep(0.2);
}
