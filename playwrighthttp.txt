// SDLC k6 | scenarios | from-playwright.http.js
// Runs the selected endpoints, emits per-feature/endpoint tags + custom metrics
// Works with your vendor/handleSummary.js to render the rich HTML report.

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Counter, Trend } from 'k6/metrics';
export { handleSummary } from '../vendor/handleSummary.js';

// ---------- Custom, tagged metrics the HTML reporter consumes ----------
const REQS_BY_EP = new Counter('reqs_by_ep');   // add(1, { feature, endpoint })
const LAT_BY_EP  = new Trend('latency_by_ep');  // add(ms, { feature, endpoint })

// ---------- Load endpoints map generated by gen-k6-endpoints ----------
/*
  File shape (generated):
  {
    "ReportingAPI Alpha1": [
      { "name": "...", "method": "GET", "url": "...", "auth": "bearer", "expect": { "status": 200, "text": "..." } },
      ...
    ],
    ...
  }
*/
const ENDPOINTS_BY_FEATURE = JSON.parse(open('../sources/endpoints.byFeature.json'));

// ---------- Env config (all optional) ----------
const ENV = __ENV || {};
const DURATION   = ENV.DURATION   || '30s';          // e.g. "60s"
const RPS        = Number(ENV.RPS || 1);             // arrivals/s
const PREALLOC   = Number(ENV.PREALLOC || 5);
const MAXVUS     = Number(ENV.MAXVUS || 35);
const BASE_URL   = (ENV.BASE_URL || '').trim();      // override host if set
const TOKEN      = (ENV.TOKEN || ENV.GRAFEAS_LOGIN_TOKEN || '').trim();

const FEATURES_RAW   = (ENV.FEATURES || '').trim();  // CSV of feature names (exactly as in JSON)
const ENDPOINT_FILTER = (ENV.ENDPOINT_FILTER || '').trim().toLowerCase(); // substring on endpoint "name"

// ---------- Helper: pick features + build flat endpoint list ----------
function selectEndpoints() {
  const allFeatures = Object.keys(ENDPOINTS_BY_FEATURE);
  const selectedFeatureNames = (FEATURES_RAW ? FEATURES_RAW.split(',') : allFeatures)
    .map(s => s.trim())
    .filter(Boolean);

  const flat = [];

  for (const f of selectedFeatureNames) {
    const eps = ENDPOINTS_BY_FEATURE[f];
    if (!eps || !Array.isArray(eps)) {
      console.warn(`Feature "${f}" not found in endpoints.byFeature.json`);
      continue;
    }
    for (const ep of eps) {
      // apply optional endpoint name substring filter
      if (ENDPOINT_FILTER && !String(ep.name || '').toLowerCase().includes(ENDPOINT_FILTER)) {
        continue;
      }

      // annotate with feature for tagging/reporting
      const epCopy = { ...ep, feature: f };

      // optional BASE_URL override: replace scheme://host portion
      if (BASE_URL) {
        try {
          const u = new URL(epCopy.url);
          const base = new URL(BASE_URL);
          u.protocol = base.protocol;
          u.host = base.host;
          epCopy.url = u.toString();
        } catch (_) {
          // keep original on parse errors
        }
      }

      flat.push(epCopy);
    }
  }

  if (!flat.length) {
    console.warn(`No endpoints selected. Check FEATURES="${FEATURES_RAW}" and ENDPOINT_FILTER="${ENDPOINT_FILTER}".`);
  } else {
    console.info(`Selected ${flat.length} endpoint(s) across FEATURES=[${selectedFeatureNames.join(', ')}]`);
  }

  return flat;
}

const ENDPOINTS = selectEndpoints();

// ---------- Build headers per method ----------
function buildHeaders(method) {
  const m = String(method || '').toUpperCase();
  const headers = {};

  // Authorization for non-GETs or when generator marked it
  if (TOKEN) {
    headers['Authorization'] = `Bearer ${TOKEN}`;
  }

  if (m === 'POST' || m === 'PUT' || m === 'PATCH') {
    headers['Content-Type'] = 'application/json';
  }

  return headers;
}

// ---------- k6 options ----------
export const options = {
  scenarios: {
    default: {
      executor: 'constant-arrival-rate',
      rate: RPS,             // iterations per second (arrivals)
      timeUnit: '1s',
      duration: DURATION,
      preAllocatedVUs: PREALLOC,
      maxVUs: MAXVUS,
    },
  },
  thresholds: {
    http_req_failed: ['rate<0.20'],          // fail if >20% requests fail
    'http_req_duration{expected_response:true}': ['p(95)<60000'], // 95th < 60s
    // keep these so the CLI/HTML shows them if present
    reqs_by_ep: ['count>=0'],
    latency_by_ep: ['p(95)>=0'],
  },
};

// Optional: log exactly one tag sample to help troubleshooting
const LOG_TAGS_ONCE = ENV.LOG_TAGS_ONCE === '1';
let _loggedOnce = false;

// ---------- Default scenario logic ----------
export default function () {
  // Iterate the currently selected endpoints once per arrival.
  for (const ep of ENDPOINTS) {
    const tags = {
      feature: ep.feature,
      endpoint: ep.name || ep.url,
    };

    const params = { headers: buildHeaders(ep.method), tags };
    const expectStatus = ep?.expect?.status ?? 200;
    const mustContain  = ep?.expect?.text;

    let res;

    try {
      switch (String(ep.method || '').toUpperCase()) {
        case 'GET':
          res = http.get(ep.url, params);
          break;
        case 'POST':
          res = http.post(ep.url, ep.body ?? '', params);
          break;
        case 'PUT':
          res = http.put(ep.url, ep.body ?? '', params);
          break;
        case 'PATCH':
          res = http.patch(ep.url, ep.body ?? '', params);
          break;
        case 'DELETE':
          // k6 DEL takes (url, body|null, params)
          res = http.del(ep.url, null, params);
          break;
        default:
          console.warn(`Unsupported method "${ep.method}" for ${tags.endpoint}`);
          continue;
      }

      // Emit custom, TAGGED metrics that the HTML summarizer aggregates
      REQS_BY_EP.add(1, tags);
      LAT_BY_EP.add(res.timings.duration, tags);

      // Checks (status + optional body contains text)
      check(res, {
        'status ok': (r) => r.status === expectStatus,
        ...(mustContain ? { 'body has text': (r) => String(r.body || '').indexOf(mustContain) !== -1 } : {}),
      }, tags);

      if (LOG_TAGS_ONCE && !_loggedOnce) {
        console.info(`tags sample: ${JSON.stringify(tags)}`);
        _loggedOnce = true;
      }
    } catch (e) {
      // still account for the attempt so totals line up
      REQS_BY_EP.add(1, tags);
      console.error(`Request failed for [${tags.feature}] ${tags.endpoint}: ${String(e)}`);
    }

    // Small pacing to avoid tight loops in a single iteration
    sleep(0.1);
  }
}
