/* eslint-disable */

/** k6 core */
const http = require('k6/http');
const { check, sleep } = require('k6');
const { Counter, Trend } = require('k6/metrics');

/** HTML report hook (keep path relative to THIS file) */
const hs = require('../vendor/handleSummary.js');

/* ---------- Env config ---------- */
const ENV = (__ENV.ENV || 'dev').toLowerCase();
const FEATURES_RAW = (__ENV.FEATURES || '').trim();           // "FeatureA,FeatureB"
const ENDPOINT_FILTER = (__ENV.ENDPOINT_FILTER || '').trim();  // substring/regex
const DURATION = __ENV.DURATION || '30s';
const RPS = Number(__ENV.RPS || 1);
const PREALLOC = Number(__ENV.PREALLOC || 5);
const MAXVUS = Number(__ENV.MAXVUS || 35);
const BASE_URL_OVERRIDE = (__ENV.BASE_URL || '').trim();
const TOKEN = (__ENV.TOKEN || '').trim();

/* ---------- Load endpoints map (generated) ---------- */
function loadMap() {
  const raw = open('../sources/endpoints.byFeature.json'); // relative to THIS file
  return JSON.parse(raw);
}
const ENDPOINTS_BY_FEATURE = loadMap();

/* ---------- Select features ---------- */
const ALL_FEATURES = Object.keys(ENDPOINTS_BY_FEATURE || {});
const SELECTED_FEATURES = FEATURES_RAW
  ? FEATURES_RAW.split(',').map(function (s) { return s.trim(); }).filter(function (s) { return !!s; })
  : ALL_FEATURES;

/* ---------- Optional endpoint filter ---------- */
var FILTER_RE = null;
if (ENDPOINT_FILTER) {
  try { FILTER_RE = new RegExp(ENDPOINT_FILTER, 'i'); } catch (e) { FILTER_RE = null; }
}

/* ---------- Flatten selection ---------- */
var ENDPOINTS = [];
for (var i = 0; i < SELECTED_FEATURES.length; i++) {
  var feat = SELECTED_FEATURES[i];
  var list = ENDPOINTS_BY_FEATURE[feat];
  if (!list || !list.length) { continue; }

  for (var j = 0; j < list.length; j++) {
    var ep = list[j];
    var nstr = String(ep.name || '');
    var matches = FILTER_RE ? FILTER_RE.test(nstr) : true;
    if (matches) {
      ENDPOINTS.push({
        feature: feat,
        url: ep.url,
        method: ep.method || 'GET',
        body: ep.body,
        expectStatus: ep.expectStatus,
        expectBodyContains: ep.expectBodyContains,
        name: ep.name
      });
    }
  }
}

/* ---------- Log selection ---------- */
console.log(
  '[k6] Selected ' + ENDPOINTS.length + ' endpoint(s) across FEATURES=[' + SELECTED_FEATURES.join(', ') + '], ' +
  'FILTER=' + (ENDPOINT_FILTER || 'none')
);
if (ENDPOINTS.length === 0) {
  console.error('[k6] No endpoints selected. Available features: ' + ALL_FEATURES.join(', '));
}

/* ---------- k6 options ---------- */
export const options = ENDPOINTS.length
  ? {
      scenarios: {
        default: {
          executor: 'constant-arrival-rate',
          rate: RPS,
          timeUnit: '1s',
          duration: DURATION,
          preAllocatedVUs: PREALLOC,
          maxVUs: Math.max(PREALLOC, MAXVUS),
        },
      },
      thresholds: {
        'http_req_duration{expected_response:true}': ['p(95) < 60000'],
      },
    }
  : { scenarios: {} };

/* ---------- Custom, taggable per-request metrics ---------- */
const reqs_ep = new Counter('reqs_ep');
const latency_ep = new Trend('latency_ep');
const checks_ep = new Counter('checks_ep');

/* ---------- Helpers ---------- */
function buildHeaders(method) {
  var h = { Accept: 'application/json' };
  if (TOKEN) h.Authorization = 'Bearer ' + TOKEN;
  return h;
}

function resolveUrl(sourceUrl) {
  if (!BASE_URL_OVERRIDE) return sourceUrl;
  try {
    var src = new URL(sourceUrl);
    var base = new URL(BASE_URL_OVERRIDE);
    base.pathname = src.pathname;
    base.search = src.search;
    return base.toString();
  } catch (_) {
    return sourceUrl;
  }
}

/* Round-robin iterator */
var rr = 0;

/* ---------- Main iteration ---------- */
export default function () {
  if (!ENDPOINTS.length) {
    sleep(0.2);
    return;
  }

  var ep = ENDPOINTS[rr++ % ENDPOINTS.length];
  var tags = { feature: ep.feature, endpoint: String(ep.name || 'unknown') };

  var url = resolveUrl(ep.url);
  var headers = buildHeaders(ep.method);

  var res;
  try {
    var m = String(ep.method || 'GET').toUpperCase();
    if (m === 'GET') res = http.get(url, { headers: headers, tags: tags });
    else if (m === 'POST') res = http.post(url, ep.body || null, { headers: headers, tags: tags });
    else if (m === 'PUT') res = http.put(url, ep.body || null, { headers: headers, tags: tags });
    else if (m === 'PATCH') res = http.patch(url, ep.body || null, { headers: headers, tags: tags });
    else if (m === 'DELETE') res = http.del(url, null, { headers: headers, tags: tags });
    else res = http.get(url, { headers: headers, tags: tags });
  } catch (e) {
    reqs_ep.add(1, tags);
    latency_ep.add(0, tags);
    checks_ep.add(0, tags);
    console.error('[k6] Request error for ' + tags.feature + ' / ' + tags.endpoint + ': ' + (e && e.message));
    sleep(0.2);
    return;
  }

  // per-request metrics
  reqs_ep.add(1, tags);
  latency_ep.add(res.timings && res.timings.duration ? res.timings.duration : 0, tags);

  var expectStatus = Number(ep.expectStatus || 200);
  var expectBody = ep.expectBodyContains || null;

  // build checks object without object spread (Goja-safe)
  var checksObj = {
    'status ok': function (r) { return r.status === expectStatus; }
  };
  if (expectBody) {
    checksObj['body has text'] = function (r) {
      var b = String(r.body || '');
      return b.indexOf(expectBody) !== -1;
    };
  }

  var ok = check(res, checksObj, tags);
  checks_ep.add(ok ? 1 : 0, tags);

  sleep(0.2);
}

/* ---------- HTML summary ---------- */
export function handleSummary(data) {
  // support both: module.exports = fn   OR   exports.handleSummary = fn
  var fn = hs && (hs.handleSummary || (typeof hs === 'function' ? hs : null));
  if (fn) return fn(data);
  // fallback: nothing
  return {};
}
