/* eslint-disable */

/** k6 core */
const http = require('k6/http');
const { check, sleep } = require('k6');
const { Counter, Trend } = require('k6/metrics');

/** HTML report hook (keep path relative to THIS file) */
const { handleSummary } = require('../vendor/handleSummary.js');

/* ---------- Env config ---------- */
const ENV = (__ENV.ENV || 'dev').toLowerCase();
const FEATURES_RAW = (__ENV.FEATURES || '').trim();           // "Feature A, Feature B"
const ENDPOINT_FILTER = (__ENV.ENDPOINT_FILTER || '').trim();  // substring/regex
const DURATION = __ENV.DURATION || '30s';
const RPS = Number(__ENV.RPS || 1);
const PREALLOC = Number(__ENV.PREALLOC || 5);
const MAXVUS = Number(__ENV.MAXVUS || 35);
const BASE_URL_OVERRIDE = (__ENV.BASE_URL || '').trim();
const TOKEN = (__ENV.TOKEN || '').trim();

/* ---------- Load endpoints map (generated) ---------- */
function loadMap() {
  const raw = open('../sources/endpoints.byFeature.json'); // relative to THIS file
  return JSON.parse(raw);
}
const ENDPOINTS_BY_FEATURE = loadMap();

/* ---------- Select features ---------- */
const ALL_FEATURES = Object.keys(ENDPOINTS_BY_FEATURE || {});
const SELECTED_FEATURES = FEATURES_RAW
  ? FEATURES_RAW.split(',').map(s => s.trim()).filter(Boolean)
  : ALL_FEATURES;

/* ---------- Optional endpoint filter ---------- */
const FILTER_RE = ENDPOINT_FILTER ? new RegExp(ENDPOINT_FILTER, 'i') : null;

/* ---------- Flatten selection ---------- */
const ENDPOINTS = [];
for (const feat of SELECTED_FEATURES) {
  const list = ENDPOINTS_BY_FEATURE[feat];
  if (!Array.isArray(list)) continue; // safe: real loop continue here is fine

  for (const ep of list) {
    const nameStr = String(ep.name || '');
    const matches = FILTER_RE ? FILTER_RE.test(nameStr) : true;
    if (matches) {
      ENDPOINTS.push({ feature: feat, url: ep.url, method: ep.method || 'GET', body: ep.body, expectStatus: ep.expectStatus, expectBodyContains: ep.expectBodyContains, name: ep.name });
    }
  }
}

/* ---------- Log selection ---------- */
console.log(
  `[k6] Selected ${ENDPOINTS.length} endpoint(s) across FEATURES=[${SELECTED_FEATURES.join(', ')}], ` +
  `FILTER=${ENDPOINT_FILTER || 'none'}`
);
if (ENDPOINTS.length === 0) {
  console.error('[k6] No endpoints selected. Available features:', ALL_FEATURES.join(', '));
}

/* ---------- k6 options ---------- */
export const options = ENDPOINTS.length
  ? {
      scenarios: {
        default: {
          executor: 'constant-arrival-rate',
          rate: RPS,
          timeUnit: '1s',
          duration: DURATION,
          preAllocatedVUs: PREALLOC,
          maxVUs: Math.max(PREALLOC, MAXVUS),
        },
      },
      thresholds: {
        'http_req_duration{expected_response:true}': ['p(95) < 60000'],
      },
    }
  : { scenarios: {} };

/* ---------- Custom, taggable per-request metrics ---------- */
const reqs_ep = new Counter('reqs_ep');
const latency_ep = new Trend('latency_ep');
const checks_ep = new Counter('checks_ep');

/* ---------- Helpers ---------- */
function buildHeaders(method) {
  const h = { Accept: 'application/json' };
  if (TOKEN) h.Authorization = `Bearer ${TOKEN}`;
  return h;
}

function resolveUrl(sourceUrl) {
  if (!BASE_URL_OVERRIDE) return sourceUrl;
  try {
    const src = new URL(sourceUrl);
    const base = new URL(BASE_URL_OVERRIDE);
    base.pathname = src.pathname;
    base.search = src.search;
    return base.toString();
  } catch (_) {
    return sourceUrl;
  }
}

/* Round-robin iterator */
let idx = 0;

/* ---------- Main iteration ---------- */
export default function () {
  if (!ENDPOINTS.length) {
    sleep(0.2);
    return;
  }

  const ep = ENDPOINTS[idx++ % ENDPOINTS.length];
  const tags = { feature: ep.feature, endpoint: String(ep.name || 'unknown') };

  const url = resolveUrl(ep.url);
  const headers = buildHeaders(ep.method);

  let res;
  try {
    switch (String(ep.method || 'GET').toUpperCase()) {
      case 'GET':
        res = http.get(url, { headers, tags });
        break;
      case 'POST':
        res = http.post(url, ep.body || null, { headers, tags });
        break;
      case 'PUT':
        res = http.put(url, ep.body || null, { headers, tags });
        break;
      case 'PATCH':
        res = http.patch(url, ep.body || null, { headers, tags });
        break;
      case 'DELETE':
        res = http.del(url, null, { headers, tags });
        break;
      default:
        res = http.get(url, { headers, tags });
        break;
    }
  } catch (e) {
    reqs_ep.add(1, tags);
    latency_ep.add(0, tags);
    checks_ep.add(0, tags);
    console.error(`[k6] Request error for ${tags.feature} / ${tags.endpoint}: ${e && e.message}`);
    sleep(0.2);
    return;
  }

  // per-request metrics
  reqs_ep.add(1, tags);
  latency_ep.add(res.timings.duration || 0, tags);

  const expectStatus = Number(ep.expectStatus || 200);
  const expectBody = ep.expectBodyContains || null;

  const ok = check(
    res,
    {
      'status ok': (r) => r.status === expectStatus,
      ...(expectBody ? { 'body has text': (r) => String(r.body || '').indexOf(expectBody) !== -1 } : {}),
    },
    tags
  );

  checks_ep.add(ok ? 1 : 0, tags);

  sleep(0.2);
}

/* ---------- HTML summary ---------- */
export function handleSummary(data) {
  return handleSummary(data);
}
