import http from "k6/http";
import { sleep } from "k6";
import { Trend, Counter } from "k6/metrics";
import features from "../sources/endpoints.byFeature.js";

// ---- custom metrics (aggregated by k6 across VUs/iters) ----
const LAT_EP = new Trend("latency_ep", /* time */ true);
const REQ_EP = new Counter("reqs_ep");

// ---------------- env ----------------
const FEAT_RAW = String(__ENV.FEATURES || "").trim();
const VUS      = Number(__ENV.VUS || "1");
const ITERS    = Number((__ENV.ITERS || __ENV.ITER || "0").toString());
const DURATION = String(__ENV.DURATION || "30s");

const SELECTED = FEAT_RAW
  ? FEAT_RAW.split(",").map(s => s.trim()).filter(Boolean)
  : [];

console.log(`parsed  -> vus=${VUS}, iters=${ITERS}, duration=${DURATION}, features=${SELECTED.length?SELECTED.join("|"):"(all)"}`);
console.log("feature map keys:", JSON.stringify(Object.keys(features || {})));

// ------------- options ---------------
export const options = ITERS > 0 ? {
  scenarios: {
    by_iter: { executor: "per-vu-iterations", vus: VUS, iterations: ITERS, maxDuration: "10m" }
  }
} : {
  scenarios: {
    by_time: { executor: "constant-vus", vus: VUS, duration: DURATION, gracefulStop: "3s" }
  }
};
console.log("executor chosen:", ITERS > 0 ? "per-vu-iterations" : "constant-vus");

// -------- build endpoints safely -----
function isPO(x){return x && typeof x==="object" && !Array.isArray(x);}
const ENDPOINTS = [];
if (!isPO(features)) {
  console.error("features export invalid; typeof =", typeof features);
} else {
  const names = SELECTED.length ? SELECTED : Object.keys(features);
  for (const fname of names) {
    const list = features[fname];
    if (!Array.isArray(list)) { console.warn("feature not found / not array:", fname); continue; }
    for (const ep of list) {
      if (!isPO(ep)) continue;
      const method = String(ep.method || "GET").toUpperCase();
      const url    = String(ep.url || "");
      if (!url) { console.warn("skip empty url in", fname); continue; }
      ENDPOINTS.push({
        feature: fname,
        name: ep.name || (method + " " + url),
        method, url,
        headers: isPO(ep.headers)?ep.headers:undefined,
        auth: ep.auth || null
      });
    }
  }
}
console.log("endpoints built:", ENDPOINTS.length);
if (ENDPOINTS.length) console.log("first endpoint:", JSON.stringify(ENDPOINTS[0]));

// ---------- tiny round-robin ---------
let idx = 0;
function pickEP() {
  if (!ENDPOINTS.length) return null;
  const ep = ENDPOINTS[idx % ENDPOINTS.length];
  idx = (idx + 1) >>> 0;
  return ep;
}

// --------------- VU code -------------
export default function () {
  const ep = pickEP();
  if (!ep) { sleep(0.25); return; }

  const params = {};
  if (ep.headers) params.headers = ep.headers;
  if (ep.auth) {
    const h = params.headers || {};
    h.authorization = String(ep.auth);
    params.headers = h;
  }

  const t0 = Date.now();
  let res;
  try {
    if (ep.method === "GET") {
      res = http.get(ep.url, params);
    } else {
      res = http.request(ep.method, ep.url, null, params);
    }
  } catch (e) {
    console.error("request error:", String(e && e.message || e));
  }
  const dur = Date.now() - t0;
  const status = res ? res.status : 0;

  // Record to custom metrics with tags (works on k6 v0.46)
  LAT_EP.add(dur, { feature: ep.feature, endpoint: ep.name, status: String(status) });
  REQ_EP.add(1,    { feature: ep.feature, endpoint: ep.name, status: String(status) });

  console.log(`[${ep.feature}] ${ep.name} -> status=${status} dur=${dur}ms`);
  sleep(0.2);
}

// ------------- summary hook ----------
export function handleSummary(data) {
  // Parse sub-metrics like: latency_ep{feature:ReportingAPI Alpha1,endpoint:Lists...,status:200}
  const perEp = [];      // rows for HTML
  const perFeat = {};    // aggregate by feature

  const metrics = data.metrics || {};
  for (const k of Object.keys(metrics)) {
    if (!k.startsWith("latency_ep{")) continue;

    // crude tag parsing from the metric name
    const tags = {};
    const tagStr = k.slice("latency_ep".length); // e.g. {feature:Foo,endpoint:Bar,status:200}
    tagStr.replace(/[{},]/g," ").trim().split(/\s+/).forEach(pair=>{
      const i = pair.indexOf(":");
      if (i>0) tags[pair.slice(0,i)] = pair.slice(i+1);
    });

    const lat = metrics[k];
    const reqKey = "reqs_ep" + tagStr;
    const req = metrics[reqKey];

    const feature  = tags.feature || "";
    const endpoint = tags.endpoint || "";
    const count = (req && req.values && (req.values.count || req.values.rate)) ? (req.values.count || 0) : 0;
    const avgMs = lat && lat.values && typeof lat.values.avg === "number" ? lat.values.avg : 0;

    perEp.push([feature, endpoint, count, Math.round(avgMs) + " ms"]);

    if (!perFeat[feature]) perFeat[feature] = { feature, count: 0, sum: 0 };
    perFeat[feature].count += count;
    perFeat[feature].sum   += (avgMs * count);
  }

  const featRows = Object.values(perFeat).map(f => {
    const avg = f.count ? Math.round(f.sum / f.count) : 0;
    return [f.feature, f.count, avg + " ms"];
  });

  function table(rows, headers) {
    const th = `<tr>${headers.map(h=>`<th style="text-align:left;padding:6px;border-bottom:1px solid #ddd">${h}</th>`).join("")}</tr>`;
    const trs = rows.map(r => `<tr>${r.map(c=>`<td style="padding:6px;border-bottom:1px solid #f0f0f0">${c}</td>`).join("")}</tr>`).join("");
    return `<table style="border-collapse:collapse;width:100%;margin:10px 0">${th}${trs}</table>`;
  }

  const html =
`<!doctype html><meta charset="utf-8">
<title>SDLC Auto Gov Load Test</title>
<div style="font:14px/1.4 system-ui,Segoe UI,Arial">
  <h2>SDLC Auto Gov Load Test â€” ${new Date().toISOString().replace("T"," ").slice(0,19)}</h2>
  <div><b>Scenarios</b>: ${Object.keys(data.options?.scenarios||{}).join(", ") || "-"}</div>

  <h3 style="margin-top:18px">Feature breakdown</h3>
  ${featRows.length ? table(featRows, ["Feature","Requests","Avg latency"]) : "<i>No feature data recorded.</i>"}

  <h3 style="margin-top:18px">Endpoint breakdown</h3>
  ${perEp.length ? table(perEp, ["Feature","Endpoint","Requests","Avg latency"]) : "<i>No endpoint data recorded.</i>"}

  <details style="margin-top:18px"><summary>Raw JSON (truncated)</summary>
    <pre style="white-space:pre-wrap;font:12px/1.4 ui-monospace,Consolas,monospace">${JSON.stringify({ options:data.options, metrics:{
      latency_ep: Object.keys(metrics).filter(k=>k.startsWith("latency_ep")).reduce((o,k)=>{o[k]=metrics[k];return o;},{}),
      reqs_ep:    Object.keys(metrics).filter(k=>k.startsWith("reqs_ep")).reduce((o,k)=>{o[k]=metrics[k];return o;},{}),
    }}, null, 2).slice(0, 8000)}</pre>
  </details>
</div>`;

  return {
    "perf/k6/reports/summary.json": JSON.stringify(data, null, 2),
    "perf/k6/reports/summary.html": html,
  };
}
