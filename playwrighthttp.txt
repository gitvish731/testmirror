/* eslint-disable */
// k6 runner built for your PW-exported endpoints map

const http = require('k6/http');
const { check, sleep } = require('k6');

// ------------ config from env (strings) ------------
const ENV = (__ENV.ENV || 'dev').toLowerCase();           // not used here but kept
const FEATURES_RAW = __ENV.FEATURES || '';                // comma/space separated
const ENDPOINT_FILTER = __ENV.ENDPOINT_FILTER || '';      // substring match (optional)
const DURATION = __ENV.DURATION || '20s';
const RPS = Number(__ENV.RPS || '1');                     // per-endpoint constant arrival
const PREALLOC = Number(__ENV.PREALLOC || '5');
const MAXVUS = Number(__ENV.MAXVUS || '50');
const SLEEP = Number(__ENV.SLEEP || '0');                 // think time per endpoint (s)

// ------------ load endpoints map ------------
/**
 * We try the JS map first (fast). If it isn’t there, we fall back to JSON via open().
 * Your generator already writes both: endpoints.byFeature.ts (compiled to .js) and .json
 */
let ENDPOINTS_BY_FEATURE = {};
try {
  // Prefer a compiled CommonJS export
  ENDPOINTS_BY_FEATURE = require('../sources/endpoints.byFeature.js').ENDPOINTS_BY_FEATURE
                       || require('../sources/endpoints.byFeature.js').default
                       || require('../sources/endpoints.byFeature.js');
} catch (_) {
  // Fallback: JSON string via open()
  try {
    const raw = open('../sources/endpoints.byFeature.json');
    ENDPOINTS_BY_FEATURE = JSON.parse(raw);
  } catch (e2) {
    throw new Error('Could not load endpoints map (byFeature.js/.json). ' + e2);
  }
}

// ------------ feature / endpoint selection ------------
function normalizeList(s) {
  return s
    .split(/[,\n]/g)
    .map(x => x.trim())
    .filter(Boolean);
}

const FEATURES = normalizeList(FEATURES_RAW);
const SELECTED_FEATURES = FEATURES.length ? FEATURES : Object.keys(ENDPOINTS_BY_FEATURE);

function matchesFilter(name, needle) {
  if (!needle) return true;
  return String(name).toLowerCase().indexOf(String(needle).toLowerCase()) !== -1;
}

// Flattened list of { feature, ep }
const ENDPOINTS = [];
for (const featureName of SELECTED_FEATURES) {
  const list = ENDPOINTS_BY_FEATURE[featureName] || [];
  for (const ep of list) {
    if (matchesFilter(ep.name, ENDPOINT_FILTER)) {
      ENDPOINTS.push({ feature: featureName, ep });
    }
  }
}

if (!ENDPOINTS.length) {
  console.log('No endpoints selected. Check FEATURES="' + FEATURES_RAW + '" and ENDPOINT_FILTER="' + ENDPOINT_FILTER + '"');
}

// ------------ scenarios (one per endpoint) ------------
/**
 * We give each endpoint a distinct scenario name (ep_#) and a constant-arrival-rate executor.
 * Each scenario’s default function multiplexes by reading its name at runtime.
 */
const scenarios = {};
ENDPOINTS.forEach((item, idx) => {
  const name = `ep_${idx}`;
  scenarios[name] = {
    executor: 'constant-arrival-rate',
    rate: RPS,
    timeUnit: '1s',
    duration: DURATION,
    preAllocatedVUs: PREALLOC,
    maxVUs: MAXVUS,
    tags: { feature: item.feature, endpoint: item.ep.name }, // scenario-level tags (nice to have)
    exec: 'runner',
  };
});

export const options = {
  scenarios,
  thresholds: {
    // keep relaxed; you can tune later
    'http_req_failed': ['rate<0.05'],
    'http_req_duration{expected_response:true}': ['p(95)<60000'],
  },
};

// ------------ util ------------
function buildHeaders(method) {
  // If your generator already puts Authorization in each ep.auth,
  // you can enrich here if needed. Keep minimal for now.
  return {};
}

function containsText(body, mustContain) {
  if (!mustContain) return true;
  if (body == null) return false;
  try {
    return String(body).indexOf(mustContain) !== -1;
  } catch (_) {
    return false;
  }
}

// ------------ runner ------------
/**
 * All scenarios call this. We figure out *which* endpoint to run by scenario.name.
 */
export function runner() {
  // Figure out which scenario we’re in
  const scenarioName = __ENV['__SCENARIO_NAME'] || ''; // k6 injects this internally
  const idx = Number(String(scenarioName).replace(/^ep_/, ''));
  const item = ENDPOINTS[idx];

  if (!item) {
    // Safety: nothing to do
    return;
  }

  const { feature, ep } = item;
  const tags = { feature, endpoint: ep.name }; // <<< CRITICAL for per-feature/per-endpoint summary
  const hdrs = buildHeaders(ep.method);

  // k6 request options with tags
  const opts = { headers: hdrs, tags };

  let res;
  const method = String(ep.method || 'GET').toUpperCase();

  if (method === 'GET') {
    res = http.get(ep.url, opts);
  } else if (method === 'POST') {
    res = http.post(ep.url, ep.body || '', opts);
  } else if (method === 'PUT') {
    res = http.put(ep.url, ep.body || '', opts);
  } else if (method === 'PATCH') {
    res = http.patch(ep.url, ep.body || '', opts);
  } else if (method === 'DELETE') {
    // k6.del(url, body?, params?)
    res = http.del(ep.url, null, opts);
  } else {
    throw new Error('Unsupported method: ' + method);
  }

  // Expectations from the generator
  const expectStatus = ep.expect && typeof ep.expect.status === 'number' ? ep.expect.status : 200;
  const expectText = ep.expect && ep.expect.text ? String(ep.expect.text) : '';

  // checks — pass tags again so pass/fail aligns with the submetrics
  check(res, {
    'status ok': (r) => r.status === expectStatus,
    'body has text': (r) => containsText(r.body, expectText),
  }, tags);

  if (SLEEP > 0) sleep(SLEEP);
}

// ------------ HTML summary ------------
export { handleSummary } from '../vendor/handleSummary.js';
